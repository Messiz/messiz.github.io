[{"content":"Raft\r脑裂\r对于MapReduce、GFS等分布式系统，都是一个Master节点与很多副节点组成的。这种单主结构足够简单，不会出现矛盾（毕竟master自己不会反对自己），但也带来了问题——一旦这个节点崩溃，那么整个系统不能正常工作。\n以Test-and-Set为例：\n实际上是单点的，我们为了提高系统的容错性，设计一个多副本的Test-and-Set服务（S1和S2）。\n现在，我们来假设我们有一个网络，这个网络里面有两个服务器（S1，S2），这两个服务器都是我们Test-and-Set服务的拷贝。这个网络里面还有两个客户端（C1，C2），它们需要通过Test-and-Set服务确定主节点是谁。在这个例子中，这两个客户端本身就是VMware FT中的Primary和Backup虚拟机。\n如果我们规定client需要与两个server同时交互，那么会比单点更糟糕，因为一旦一个server崩溃，则不能正常服务，导致有副本系统反而没有容错性； 如果我们规定只与其中一个server交互即可，则会发生脑裂。 当时（1980s）解决脑裂大致两种方法：\n构建不会出错的“网络” 人工解决问题，出现问题时，停止提供服务，由人工检查问题 过半票决（Majority Vote）\r完成任何操作，都需要过半的服务器（总服务器数的一半以上）批准来完成对应操作。\n服务器总数应该为奇数； 假设系统有2*F+1个服务器，那么系统最多可接受F个服务器故障（F+1个服务器正常运行），仍然可以正常工作； 过半票决的一个特性是：每一个操作对应的过半服务器，必然至少包含一个服务器存在于上一个操作的过半服务器中。下面的例子说明了这一点： 过半票决系统的一个特性就是，最多只有一个网络分区会有过半的服务器，所以我们不可能有两个分区可以同时完成操作。这里背后更微妙的点在于，如果你总是需要过半的服务器才能完成任何操作，同时你有一系列的操作需要完成，其中的每一个操作都需要过半的服务器来批准，例如选举Raft的Leader，那么每一个操作对应的过半服务器，必然至少包含一个服务器存在于上一个操作的过半服务器中。也就是说，任意两组过半服务器，至少有一个服务器是重叠的。实际上，相比其他特性，Raft更依赖这个特性来避免脑裂。例如，当一个Raft Leader竞选成功，那么这个Leader必然凑够了过半服务器的选票，而这组过半服务器中，必然与旧Leader的过半服务器有重叠。所以，新的Leader必然知道旧Leader使用的任期号（term number），因为新Leader的过半服务器必然与旧Leader的过半服务器有重叠，而旧Leader的过半服务器中的每一个必然都知道旧Leader的任期号。类似的，任何旧Leader提交的操作，必然存在于过半的Raft服务器中，而任何新Leader的过半服务器中，必然有至少一个服务器包含了旧Leader的所有操作。这是Raft能正确运行的一个重要因素。 Raft初探\rRaft作为Library运行在服务中，为服务提供一致性保证。如上图，一个服务的副本由两部分组成：上半部分是应用程序（APP）（上图中是一个KV Server），下半部分是Raft库。\n执行流程：\nClient发送请求至Leader节点的APP； APP将Client请求向下发送至Raft层，Raft层将操作存入日志； Raft将此操作发送值所有副本； 当Leader得知过半的阶段都有了这个操作的拷贝后，发送消息至上层APP，告知APP可以实际执行这个操作了；此后所有其他副本都将操作提交至本地的APP执行，理想情况下，整个系统的所有副本都执行了此操作，APP与Raft状态应都保持一致。 Log同步时序\r在系统正常工作没有故障时，Raft Log 同步流程的时序图如上：\nClient发送请求； Leader向其余所有副本同步消息（AppendEntries RPC，用于日志同步与心跳信号传递）； 待收到超半数的确认后提交（对于上面三个副本的系统，包括Leader自身只需要额外收到一个节点的确认即可）； Leader将提交的消息同步给其他副本，通知它们可以提交操作（在Raft中，没有单独的提交信息，commit消息是携带在下一次的AppendEntries RPC中的）。 日志（Raft Log）\r日志的作用：\nLeader用来对操作进行排序，这对于复制状态机十分重要； Follower用于临时存储操作，待收到Leader的commit消息执行操作； Leader中存放操作，如果因为网络或其他问题导致副本没有收到消息，可以进行消息重传； 所有节点都会将Log持久化，这有助于节点故障后恢复状态。 Leader选举（Leader Election）\rRaft中设置Leader的好处在于，对于一个请求，存在Leader的情况下，只需一轮交互即可取得过半服务器的确认，而对于无Leader系统，通常需要一轮消息确认一个临时Leader，第二轮消息才能实际确认请求，性能更高； 在Raft生命周期中，通过**任期号（term number）**来区分不同的Leader，每个任期内最多只有一个Leader（可能没有或者有一个）； 每个Raft节点都有一个选举定时器（Election Timer），当此定时器时间耗尽之前，没有收到任何来自Leader的消息，则认为Leader已经下线，并开始一次新的选举； 任何一条AppendEntries消息的到达都会重置选举定时器，因此，在网络正常且节点无故障的情况下，不会进行新的选举； 选举失败可能的情况： 可投票节点不足（网络故障或服务器关机等） 分割选票（Split Vote）：如果若干节点选举定时器同时到期，同时都发出了RequestVote消息，这造成所有这些节点都无法获得足够的选票，就会导致这次选举失败。Raft不能完全避免这种情况发生，但是可以大大降低发生概率：为选举定时器随机选择超时时间，以降低多个节点同时超时的发生概率。 超时时间选择：下限不能低于一个心跳间隔，否则会一直超时，通常可以设置为2-3个心跳时间；上限选择取决于期望的故障恢复速度，同时要保证随机的超时时间间隔足够完成选举。 开始一次选举时，当前服务器会增加任期号（term number），并发出请求投票（RequestVote）RPC，这个消息会发送至其他所有节点（因为自己总会投票给自己）； 相同的，选举视为一次操作的话，也需要获得超半数的同意票才能当选。每个Raft节点在一个任期内只会进行一次投票，保证了一次选举最多只会当选一个Leader； 当选的Leader会立刻发送AppendEntries告知其他所有节点，当然不是直接写“我当选了Leader！”，而是附带上当前任期号，而由于Raft规定，对于某个任期，只有Leader才能发出AppendEntries消息。 系统故障下的机制\r日志恢复（Log Backup）\r当Raft系统发生故障时，可能系统中不同节点中保存的log不一致，下面举例说明：\n服务器 Slot 10 Slot 11 Slot 12 Slot 13 S1 3 S2 3 3 4 S3 3 3 5 6 有S1、S2、S3三个服务器，在任期3中，第一次请求三者都成功记录，第二次请求只有S2、S3记录，S1记录失败，包含三种情况（假设S3是任期3的Leader）： 发送给S1的消息丢了 S1当时已经关机了 S3在向S2发送完AppendEntries之后，在向S1发送AppendEntries之前故障了 继续往后看： S2称为Leader后接受一个请求后崩溃，需要进行重新选举 S3成功当选，获得请求，并且崩溃 假设下一个任期是6，并且S3当选Leader，S3会发送任期6的第一个AppendEntries RPC给其他两个follower，其中不仅包括本条log相关信息，还包括： prevLogIndex 前一项log的槽位 prevLogTerm 前一项log的Term number S2检查是否匹配，结果发现自己前一项Log的任期为4而非5，因此会拒绝这个AppendEntries RPC，并返回False给Leader S3，S1前一项没有值，因此也将拒绝这个AE RPC。 Leader中还维护了Follower的nextIndex，nextIndex的初始值为新当选的Leader的最后一条日志位置，在上例中就是13。而由于Leader收到两个Follower的False，则会减小对应的nextIndex，此时nextIndex=12，prevLogIndex=11，prevLogTerm=3，此时发送的AE消息包含了prevLogIndex后的所有条目（也就是12，13两个槽的内容）。 此时S2发现prevLogIndex和prevLogTerm与自己记录相符，则接受此AE，并将后续的数据写入自己Log的相同位置（删除了Slot 12中的4，这是安全的因为4没有被commit）。 S1此时仍不符合，因此还是拒绝。 Leader重复前面的流程，直至S1也确认AE，并将正确Log写入。 快速恢复（Fast Backup）\r如果Follower进度和Leader差太多（例如：差1000个任期），此时进行日志恢复就会造成巨大的时间开销（需要发送1000条AE）。\n一种快速恢复策略如下：\n在新Leader发送第一个AE后，每个Follower回复都附带上一些额外信息： XTerm：Follower中与Leader冲突的Log对应的任期号。在之前有介绍Leader会在prevLogTerm中带上本地Log记录中，前一条Log的任期号。如果Follower在对应位置的任期号不匹配，它会拒绝Leader的AppendEntries消息，并将自己的任期号放在XTerm中。如果Follower在对应位置没有Log，那么这里会返回 -1。 XIndex：这个是Follower中，对应任期号为XTerm的第一条Log条目的槽位号。 XLen：如果Follower在对应位置没有Log，那么XTerm会返回-1，XLen表示空白的Log槽位数。 下面假设三个场景\nCase 1：Follower（S1）会返回XTerm=5，XIndex=2。Leader（S2）发现自己没有任期5的日志，它会将自己本地记录的，S1的nextIndex设置到XIndex，也就是S1中，任期5的第一条Log对应的槽位号。所以，如果Leader完全没有XTerm的任何Log，那么它应该回退到XIndex对应的位置（这样，Leader发出的下一条AppendEntries就可以一次覆盖S1中所有XTerm对应的Log）。 Case 2。Follower（S1）会返回XTerm=4，XIndex=1。Leader（S2）发现自己其实有任期4的日志，它会将自己本地记录的S1的nextIndex设置到本地在XTerm位置的Log条目后面，也就是槽位2。下一次Leader发出下一条AppendEntries时，就可以一次覆盖S1中槽位2和槽位3对应的Log。 Case 3。Follower（S1）会返回XTerm=-1，XLen=2。这表示S1中日志太短了，以至于在冲突的位置没有Log条目，Leader应该回退到Follower最后一条Log条目的下一条，也就是槽位2，并从这开始发送AppendEntries消息。槽位2可以从XLen中的数值计算得到。 选举约束（election Restriction）\r候选人最后一条Log条目的任期号大于本地最后一条Log条目的任期号； 或者，候选人最后一条Log条目的任期号等于本地最后一条Log条目的任期号，且候选人的Log记录长度大于等于本地Log记录的长度 持久化（Persistence）\rRaft持久化存储三种数据：\nLog：Log记录APP的所有操作，Raft并没有规定持久化APP的运行状态，因此，Log是唯一保存APP状态的数据，当从故障恢复时，可以从Log逐条读取数据恢复APP状态； currentTerm：与voteFor保证Leader选举的正确性，新的Leader需要知道正确的Term number，假设前一个Leader故障，而剩下的两个Follower缺失一些Log，导致不知道正确Term，那么重新选举会造成新Leader存储错误Term number； voteFor：不存储voteFor会造成重复投票，造成脑裂。S1为S2投完票后故障，恢复后又收到S3的投票请求，而认为自己没有投过票，又给S3投票，可能造成两个Leader的情况发生。 日志快照（Log Snapshot）\rRaft系统长时间运行会造成Log内容过多的情况，这对于持久化以及故障后恢复的效率会产生较大影响。因此，提出快照（Snapshots）。\n当Raft判断Log大小达到某个阈值时，会要求程序在Log的特定位置上，对其状态做一个快照，然后Raft丢弃这一点之前的Log。\n可能出现的问题：当Follower落后太多，以至于Leader产生快照丢弃的Log无法恢复时，Leader和Follower的一致性会遭到破坏。\nRaft的解决方案如下：\n引入一个新的消息类型，InstallSnapshot RPC\n当Follower刚刚恢复，如果它的Log短于Leader通过 AppendEntries RPC发给它的内容，那么它首先会强制Leader回退自己的Log。在某个点，Leader将不能再回退，因为它已经到了自己Log的起点。这时，Leader会将自己的快照发给Follower，之后立即通过AppendEntries将后面的Log发给Follower。\n线性一致（Linearizability）\r线性一致或者说强一致，定义了一个分布式系统正确的处理逻辑，在客户端看来，就和与单点服务交互一样。\n**定义：一个系统是线性一致的，**如果执行历史整体可以按照一个顺序排列，且排列顺序与客户端请求的实际时间相符合；并且，每一个读操作都看到的是最近一次写入的值。\n","date":"2024-09-18T02:15:02+08:00","permalink":"http://localhost:1313/p/lab-3-raft/","title":"Lab-3 Raft"},{"content":"测试\r123123123123\n","date":"2024-09-17T00:00:00Z","image":"http://localhost:1313/p/lab-1-mapreduce/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/lab-1-mapreduce/","title":"Lab-1 MapReduce"},{"content":"{.headerlink}数据结构\r{.headerlink}哈希\r{.headerlink}拉链法\r{.headerlink}开放寻址法\r{.headerlink}字符串哈希\r字符串哈希用于快速判断两字符串是否相同，时间复杂度为O(1)，需要保证的前提是不同的字符串映射后的值不相等（即要求哈希表不发生冲突）。\n举例来看：对于字符串\u0026quot;abcd\u0026quot;，将其看作一个P进制的数，则\u0026quot;abcd\u0026quot;映射的值取为：\n(a*P^3 + b*P^2 + c*P^1 + d*P^0) mod Q\n其中a，b，c，d分别为ascii码。\n通常将P取值为 131 或 13331 可以尽可能地避免冲突。（玄学），由于溢出，需要对Q取模，Q一般取为2^64，故可以直接用unsigned long long 来存储（恰好是2^64），溢出就相当于取模，因此省去了取模的计算。\n对于一个字符串，假设h(i)表示其i前缀的哈希值，例如上述例子中h(2)表示\u0026quot;ab\u0026quot;的哈希值。则h(i)的初始化可以用以下式子：\nh(i) = h(i - 1) * P + str(i)\n其中h(0) = 0\n要得到第l到第r位之间的字符串哈希值，则用以下公式：\nvalue = h(r) - h(l - 1) * P^(r - l + 1)\n{.headerlink}图论\u0026amp;搜索\r{.headerlink}数和图的存储\r{.headerlink}邻接矩阵\rg[a][b]表示a节点指向b节点的边，无权值则可用bool数组，有权值则保存对应权值。\n{.headerlink}邻接表\r类似hash表拉链法\n1 2 3 4 5 6 7 8 9 10 11 12 // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a-\u0026amp;gt;b void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 初始化 idx = 0; memset(h, -1, sizeof h); h数组下标表示第几个结点，而e和ne点的下标则表示第几个添加的，注意：不同时间添加的可能指的是同一个结点。比如：第4次操作添加了结点5，而第9次操作又添加的结点5，h[5]表示的是第5个结点邻接表的首元素(的下标)，而e[4]和e[9]都等于5；ne[4]和ne[9]则分别表示这两次操作对5这个结点的不同指向(或被指向)。\n{.headerlink}深度优先遍历(DFS)\r1 2 3 4 5 6 7 8 9 10 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } {.headerlink}广度优先遍历(BFS)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 queue\u0026amp;lt;int\u0026amp;gt; q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } } {.headerlink}最短路问题\r{.headerlink}Dijkstra最短路算法\r","date":"2021-02-25T00:00:00Z","permalink":"http://localhost:1313/p/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"算法学习笔记"},{"content":"废话不多说，直接上题目：\n有三种帐篷：三人，双人，情侣，给定其价格p1, p2, p3，以及男女人数，及其中情侣对数，问最佳方案（总价格最低）。\nps：三人和双人帐篷可以不住满，但情侣帐篷必须住满\n代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 #include\u0026amp;lt;iostream\u0026amp;gt; using namespace std; //参数依次为男生人数，女生人数，情侣人数，三人帐篷价格，双人帐篷价格，爱心帐篷价格 void schedual(int boy, int girl, int couple, int p1, int p2, int p3) { int b = boy, g = girl, c = couple; int current_tent[3] = { 0 }; //当前方案帐篷数 int min_tent[3] = { 0 }; //最佳方案帐篷数 int current_price = 0; //当前方案价格 int min_price = INT_MAX; //最佳方案价格 //p1三人, p2双人, p3爱心 //单价（帐篷住满时每人的开销） double sp1 = p1 / 3.0; double sp2 = p2 / 2.0; double sp3 = p3 / 2.0; //从爱心帐篷顶数入手，遍历所有可能(0~couple)，剩下的男女按照帐篷价格以及单价来确定各自顶数 for (int i = 0; i \u0026amp;lt;= couple; i++) { boy -= i; girl -= i; current_price += p3 * i; current_tent[2] += i; if (p1 \u0026amp;lt; p2) //三人帐篷价格低于双人帐篷 { while (boy \u0026amp;gt; 0) { current_price += p1; current_tent[0]++; boy -= 3; } while (girl \u0026amp;gt; 0) { current_price += p1; current_tent[0]++; girl -= 3; } } else if (sp1 \u0026amp;lt; sp2)//三人帐篷价格高于双人帐篷，但单价低于双人帐篷 { while (boy \u0026amp;gt;= 3) { current_price += p1; current_tent[0]++; boy -= 3; } while (girl \u0026amp;gt;= 3) { current_price += p1; current_tent[0]++; girl -= 3; } if (p1 / 2.0 \u0026amp;lt; p2 / 2.0)//两人住三人帐篷低于双人 { while (boy \u0026amp;gt; 0) { current_price += p1; current_tent[0]++; boy -= 3; } while (girl \u0026amp;gt; 0) { current_price += p1; current_tent[0]++; girl -= 3; } } else//两人住三人帐篷高于双人 { while (boy \u0026amp;gt; 0) { current_price += p2; current_tent[1]++; boy -= 2; } while (girl \u0026amp;gt; 0) { current_price += p2; current_tent[1]++; girl -= 2; } } } else//三人价格高于双人，单价同样 { while (boy != 3 \u0026amp;amp;\u0026amp;amp; boy \u0026amp;gt; 0) { current_price += p2; current_tent[1]++; boy -= 2; } while (girl != 3 \u0026amp;amp;\u0026amp;amp; girl \u0026amp;gt; 0) { current_price += p2; current_tent[1]++; girl -= 2; } if (p1 \u0026amp;lt; 2 * p2)//三人价格低于两个双人 { while (boy \u0026amp;gt; 0) { current_price += p1; current_tent[0]++; boy -= 3; } while (girl \u0026amp;gt; 0) { current_price += p1; current_tent[0]++; girl -= 3; } } else { while (boy \u0026amp;gt; 0) { current_price += p2; current_tent[1]++; boy -= 2; } while (girl \u0026amp;gt; 0) { current_price += p2; current_tent[1]++; girl -= 2; } } } if (current_price \u0026amp;lt; min_price) { min_price = current_price; min_tent[0] = current_tent[0]; min_tent[1] = current_tent[1]; min_tent[2] = current_tent[2]; } //恢复数据，便于下一次循环 boy = b; girl = g; couple = c; current_price = 0; current_tent[0] = 0; current_tent[1] = 0; current_tent[2] = 0; } cout \u0026amp;lt;\u0026amp;lt; \u0026amp;quot;最低价格：\u0026amp;quot; \u0026amp;lt;\u0026amp;lt; min_price \u0026amp;lt;\u0026amp;lt; endl; cout \u0026amp;lt;\u0026amp;lt; \u0026amp;quot;三人帐篷：\u0026amp;quot; \u0026amp;lt;\u0026amp;lt; min_tent[0] \u0026amp;lt;\u0026amp;lt; endl; cout \u0026amp;lt;\u0026amp;lt; \u0026amp;quot;双人帐篷：\u0026amp;quot; \u0026amp;lt;\u0026amp;lt; min_tent[1] \u0026amp;lt;\u0026amp;lt; endl; cout \u0026amp;lt;\u0026amp;lt; \u0026amp;quot;爱心帐篷：\u0026amp;quot; \u0026amp;lt;\u0026amp;lt; min_tent[2] \u0026amp;lt;\u0026amp;lt; endl; } int main() { //测试数据 schedual(5, 5, 2, 6, 1, 2); schedual(5, 5, 4, 3, 2, 1); schedual(102, 69, 45, 8, 5, 4); schedual(32, 24, 16, 5, 4, 3); schedual(82, 56, 23, 8, 7, 5); schedual(52, 74, 40, 6, 6, 4); return 0; } ","date":"2020-09-23T00:00:00Z","permalink":"http://localhost:1313/p/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A_1/","title":"算法分析作业_1"},{"content":"写在前面\n其实不想写的，因为晚上有课，但还是稍微说一点。\n前两题加了注释，后两题没加，也许晚上会加。总之我要先上课了。\n修改\n简化第二题delete方法为1行代码 更改第二题（13）和第三题（5），对不起各位！ 第一题\n直接上代码了，前两题有注释：\nNumUtil\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 /** * 1.C语⾔标准库函数int atoi (const char *)和long int atol ( const char *)，可以分别将给定的字符串转 * 换为整数（int）和⻓整数（long）。具体转换规则如下：丢弃前⾯的空⽩字符（空格、⽔平以及垂 * 直制表、换⻚、回⻋、换⾏，其相应的ASCII码值附后），直到第⼀个⾮空⽩字符为⽌；从该字符开 * 始，接收可选的+或-号，后跟任意的⼗进制数字字符并将其解释为数字值；字符串在构成整数的数 * 字字符之后可以包含额外的其它字符，⼀旦遇到这样的字符，转换⽴即停⽌；如果字符串的第⼀个 * ⾮空⽩字符并不是⼀个有效的数字字符，或者它为空或仅仅包含空⽩字符，那么不会执⾏转换，仅 * 仅返回0。以下是对外提供这两个功能的NumUtil类，请根据该转换规则以及中的注释：（1）如果类 * 或有关⽅法的声明中存在错误，说明如何修改。 main()⽅法体中，除了编号部分，不允许被修改。 * （2）完成相关⽅法，要求不得使⽤标准Java⾃身的有关解析数值的类及其⽅法；（3）在main()⽅ * 法中，根据下表中所给的测试⽤例执⾏单元测试（并⾮实际产品开发中的测试⽅式）。 */ // NumUtil.java public class NumUtil { //将提供的功能函数均改为static，否则在main函数中无法调用 //由于是提供函数的Util类，需改为public /** * Determine if the given character is a whitespace. * * @param c the character to check. * @return true, if the given character is a whitespace; * false, otherwise. */ static private boolean isWhitespace(char c) { // (1) switch (c) { case \u0026amp;#39; \u0026amp;#39;: //空格 case \u0026amp;#39;\\t\u0026amp;#39;: //制表符 case \u0026amp;#39;\\f\u0026amp;#39;: //换页 case \u0026amp;#39;\\r\u0026amp;#39;: //回车 case \u0026amp;#39;\\n\u0026amp;#39;: //换行 case \u0026amp;#39;\\u000b\u0026amp;#39;: // \\v，垂直制表符，java中没有，故用Unicode编码 return true; default: return false; } } /** * Determine the position of the first non-whitespace character * in the given string. * * @param source the string to examine. * @return the position of the first non-whitespace character * in the given string. */ static private int skipWhitespace(String source) { // (2) int i = 0; while (i \u0026amp;lt; source.length()) { if (isWhitespace(source.charAt(i))) i++; else break; } return i; //i表示第一个非空白字符位置，若i等于字符串长度则表示全空白 } /** * Try to convert the given string to a long integer.* @param source the string to convert. * * @return the converted long integer. */ public static long atol(String source) { int sign = 1, i; // sign of the result long integer, i current position in source long res = 0; // the final result long integer // skip the whitespaces // (3) i = skipWhitespace(source); //获取第一个非空白字符位置 if (i == source.length()) return res; //若全空，则返回0 // process the sign symbol // (4) switch (source.charAt(i)) { case \u0026amp;#39;+\u0026amp;#39;: //sign初始值为1 i++; break; case \u0026amp;#39;-\u0026amp;#39;: sign = -1; //修改sign为-1（符号） i++; break; default: break; } // process any digit characters // (5) for (; i \u0026amp;lt; source.length(); i++) { char c = source.charAt(i); if (c \u0026amp;gt;= \u0026amp;#39;0\u0026amp;#39; \u0026amp;amp;\u0026amp;amp; c \u0026amp;lt;= \u0026amp;#39;9\u0026amp;#39;) res = 10 * res + c - \u0026amp;#39;0\u0026amp;#39;; //由于从前向后遍历，故每次扩大10倍 else break; } // return the converted result long integer return sign * res; } /** * Try to convert the given string to an integer. * * @param source the string to convert. * @return the converted integer. */ public static int atoi(String source) { // (7) return (int) atol(source); //调用atol函数，将long型结果变量强转为int } /** * Determine if the given test had passed and output the result * according to the following format: * \u0026amp;lt;pre\u0026amp;gt; * Test case: n -\u0026amp;gt; passed|failed * where n is the number of the test case. * \u0026amp;lt;/pre\u0026amp;gt; * * @param test the number of the test case. * @param factual the converted integer. * @param expected the expected integer. */ public static void check(int test, int factual, int expected) { // (8) System.out.print(\u0026amp;quot;Test case: \u0026amp;quot; + test + \u0026amp;quot; -\u0026amp;gt; \u0026amp;quot;); if(factual == expected) System.out.println(\u0026amp;quot;passed\u0026amp;quot;); else System.out.println(\u0026amp;quot;failed\u0026amp;quot;); } // Just for test! public static void main(String[] args) {// test case 1 String source = \u0026amp;quot;\u0026amp;quot;; int res = atoi(source); check(1, res, 0); // test case 2 // (9) source = \u0026amp;quot; \\t\\u000b\\f\\r\\n\u0026amp;quot;; //根据pdf中\u0026amp;quot;空格|⽔平制表|垂直制表|换⻚|回⻋|换⾏\u0026amp;quot; res = atoi(source); check(2, res, 12345); // test case 3 // … // test case 4 // … // test case 5 // … } } 第二题\nCacheItem\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /** * 2.在Web应⽤程序中，为了提⾼系统的响应性，可以将⽤户请求的结果缓存在内存中。当⽤户后续 * 请求相同的资源时，不必从数据存储中提取，⽽可以直接从内存中提供；当某个⽤户对相同的资源 * 进⾏更新时，除了更新数据存储，还应该更新缓存，但统⼀资源标识符（URI-Uniform Resource * Identifier）不能更改；当请求删除某个资源被时，除了从数据存储中将其删除之外，如果该资源已 * 经被缓存，还应将其从缓存中删除；为了降低系统内存的消耗，每隔⼀定的时间，应该清除缓存中 * 超过⼀定期限的项⽬。缓存的项⽬中包括请求的URI（字符串形式）、应答体（字符串形式）以及进 * ⼊缓存的时间（UNIX纪元即⾃从1970年1⽉1⽇0时0分0秒以来的毫秒数）。为了简单起⻅，不考虑 * 多服务器的分布式缓存⽽仅仅考虑单台服务器，但需要考虑多线程同步问题。以下表示HTTP应答缓 * 存的类HttpCache在整个JVM中只能有⼀个实例，要求采⽤惰性（lazy）⽅式实例化，并且在多线程 * 环境下，对该类的实例化不得采⽤同步锁。所需要的有关类的⽅法在后续的表中给出。请编写以下 * 代码⻣架中编号为(1)、 (2)等部分的代码（答题时标注相应的序号）并说明HttpCache在多线程环境 * 下哪些些⽅法需要同步以及在当前条件下如何同步。测试数据在后⾯的表格中给出。 */ package com.njfu.cache; public class CacheItem { private String uri; private long since; private String body; // constructor // (1) public CacheItem(String uri, String body) { //构造方法 this.uri = uri; this.body = body; this.since = System.currentTimeMillis(); } // accessor for uri // (2) public String getUri() { return this.uri; } public void setUri(String uri) { this.uri = uri; } // accessor for since // (3) public long getSince() { return this.since; } public void setSince(long since) { this.since = since; } // accessor for body // (4) public String getBody() { return this.body; } public void setBody(String body) { this.body = body; } // When call System.out.println(aCacheItem), output “URI: uri, Since: since, Body: body” // (5) @Override public String toString() { //覆盖toString方法 return new String(\u0026amp;quot;URI: \u0026amp;quot; + this.uri + \u0026amp;quot;, Since: \u0026amp;quot; + this.since + \u0026amp;quot;, Body: \u0026amp;quot; + this.body); } } HttpCache\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 // (6) package com.njfu.cache; import java.util.HashMap; import java.util.Iterator; // for Java 8- import java.util.Map; import java.util.Set; // Optional // Don’t inherit from HahMap etc. public class HttpCache { // Cache all the HTTP responses private Map\u0026amp;lt;String, CacheItem\u0026amp;gt; cache; // Make the globall instance of the HTTP response cache // (7) private static class CacheMaker { private static final HttpCache instance = new HttpCache(); } // constructor // (8) private HttpCache() { //构造器private，禁止直接实例化 this.cache = new HashMap\u0026amp;lt;\u0026amp;gt;(); } /** * Retrieve the globally unique instance of the HTTP response cache. * * @return the globally unique instance of the HTTP response cache. */ public static HttpCache getInstance() { // (9) /** * 当第一次调用getInstance()时， * 虚拟机发现访问了CacheMaker.instance， * 但这是CacheMaker这个静态内部类的一个静态成员， * 但它并没有被初始化，事实上JVM这个时候加载该静态内部类， * 并初始化其instance成员 * 但JVM在加载类的时候，会确保多线程同步， * 所以不会存在将HttpCache创建两个或更多的实例的情况 */ return CacheMaker.instance; } /** * Cache the HTTP response to the given resource URI. * * @param uri the URI of the requested resource. * @param body the HTTP response body for the requested resource. * @return true, if the cache item for the given URI has already * existed, it was just updated; false, this is a new resource * request. */ public boolean cache(String uri, String body) { // (10) CacheItem item = this.cache.get(uri); //用uri从map中尝试寻找 if (item == null) { //找不到则创建新CacheItem，并加入map中 this.cache.put(uri, new CacheItem(uri, body)); return false; } //找到则更新body和since item.setBody(body); item.setSince(System.currentTimeMillis()); return true; } /** * Try to retrieve the cached response body by the given request URI. * * @param uri the request URI whose response body would be retrieved. * @return the response body corresponding to the given request * URI or null if the cache does not contain it. */ public String get(String uri) { //上面注释中说的比较清楚了，通过uri查找对应cache中body内容 // (11) CacheItem item = this.cache.get(uri); return item == null ? null : item.getBody(); } /** * Remove the cached HTTP response by the given resource URI. * * @param uri the URI of the resource to deleted. * @return true, if the cache do contain the HTTP response for * the given resource URI and it was deleted; false, otherwise. */ public boolean delete(String uri) { // (12) // CacheItem item = this.cache.get(uri); // if(item == null) { //未找到，返回false // return false; // } //否则删除map中的项，返回true //简化为1行代码 return cache.remove(uri) != null; // return true; } /** * Delete all the cached HTTP responses earlier than the given * threshold. * * @param delta the period in milliseconds that determine all * the responses ahead of the current time delta milliseconds * would be deleted. */ public void purge(long delta) { // (13) //包括Java 8前后不同的实现 long now = System.currentTimeMillis(); //java 8+ this.cache.entrySet().removeIf(e -\u0026amp;gt; e.getValue().getSince() \u0026amp;lt;= now - delta); //java 8- for (Iterator\u0026amp;lt;Map.Entry\u0026amp;lt;String, CacheItem\u0026amp;gt;\u0026amp;gt; iter = cache.entrySet().iterator(); iter.hasNext(); ) { if(iter.next().getValue().getSince() \u0026amp;lt;= now - delta) { iter.remove(); } } } // Just for test @Override public String toString() { return this.cache.toString(); } // Just for test, multi-threads not concerned! public static void main(String[] args) { // In this case, ‘the HttpCache.’ part is optional HttpCache.getInstance().cache(\u0026amp;quot;185080101\u0026amp;quot;, /*(14)*/ \u0026amp;quot;no: \\\u0026amp;quot;185080101\\\u0026amp;quot;, name: \\\u0026amp;quot;zhangsan\\\u0026amp;quot;, gender: \\\u0026amp;quot;M\\\u0026amp;quot;\u0026amp;quot;); //… HttpCache.getInstance().cache(\u0026amp;quot;185080102\u0026amp;quot;, \u0026amp;quot;no: \\\u0026amp;quot;185080102\\\u0026amp;quot;, name: \\\u0026amp;quot;lisi\\\u0026amp;quot;, gender: \\\u0026amp;quot;F\\\u0026amp;quot;\u0026amp;quot;); HttpCache.getInstance().cache(\u0026amp;quot;185080103\u0026amp;quot;, \u0026amp;quot;no: \\\u0026amp;quot;185080103\\\u0026amp;quot;, name: \\\u0026amp;quot;wangwu\\\u0026amp;quot;, gender: \\\u0026amp;quot;M\\\u0026amp;quot;\u0026amp;quot;); } } 第三题\nDatagramServer\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.util.function.Consumer; /** * 3.以下是客户端通过数据报同服务器单向通信的代码框架。客户端从控制台上接收⽤户输⼊，按回 * ⻋键后将所输⼊的内容发送给服务器，当⽤户输⼊EOF时，客户端退出；服务器端在本地环回接⼝ * 上接收来⾃客户端的数据报并将其内容显示到终端窗⼝的，请根据其中的注释完成编号为(1)、 (2)等 * 的代码。 */ public class DatagramServer { // Port number private static final int SERVER_PORT = 8888; // Receiving buffer size, maximum 1KB. For UDP, this is enough private static final int BUF_SIZE = 1024; public static void main(String args[]) throws Exception { // Used to log the received packet to console Consumer\u0026amp;lt;String\u0026amp;gt; logger = /*(1)*/System.out::println; // Create a datagram socket DatagramSocket server = /*(2)*/new DatagramSocket(SERVER_PORT, InetAddress.getLoopbackAddress()); // Receiving buffer for datagram packet byte[] buf = new byte[BUF_SIZE]; // Keep running forever for(;;) { // Create a new packet DatagramPacket packet = /*(3)*/new DatagramPacket(buf, BUF_SIZE); // Try to receive the datagram packet /*(4)*/server.receive(packet); // Use logger to write the content of the received packet to the console /*(5)*/logger.accept(new String(packet.getData(), 0, packet.getLength())); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; public class DatagramClient { // Server port number private static final int SERVER_PORT = 8888; // Client port private static final int CLIENT_PORT = 8889; // Size of the message buffer private static final int BUF_SIZE = 1024; public static void main(String args[]) throws Exception { // Create a datagram socket DatagramSocket client = /*(6)*/new DatagramSocket(CLIENT_PORT, InetAddress.getLoopbackAddress()); // Data buffer for datagram packet byte[] buf = new byte[BUF_SIZE]; // Read user input from the console. When hit EOF, exist // pos - the next position where to write the character. for(int pos = 0, c; /*(7)*/(c = System.in.read()) != -1;) { switch(c) { case \u0026amp;#39;\\r\u0026amp;#39;: // Windows break; case \u0026amp;#39;\\n\u0026amp;#39;: // Finished a line // Send the message contained in the buffer /*(8)*/client.send(new DatagramPacket(buf, pos, InetAddress.getLoopbackAddress(), SERVER_PORT)); // Reset the buffer /*(9)*/pos = 0; break; default: // Cache the current character // assume no more than BUF_SIZE buf[pos++] = (byte)c; } } System.out.println(\u0026amp;quot;Goodbye!\u0026amp;quot;); // Close the datagram socket /*(10)*/client.close(); } } 第四题\nMailPanel\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import javax.swing.*; import java.awt.*; /** * 根据以下所给定的简单电⼦邮件客户端的截图，以及以下代码⻣架中的注释，完成编号为(1)、 (2) * 等部分的代码。当点击按钮“退出”时，终⽌该客户端的运⾏，要求采⽤Lambda表达式。 */ public class MailPanel extends JPanel { public MailPanel() { // create main panel and set grid bag layout super( /*(1)*/new GridBagLayout() ); // create grid bag contraints GridBagConstraints c = /*(2)*/new GridBagConstraints(); // row 0, column 0 -\u0026amp;gt; 主题: // (3) c.gridx = 0; c.gridy = 0; this.add(new JLabel(\u0026amp;quot;主题：\u0026amp;quot;), c); // row 0, column 1 -\u0026amp;gt; text field for subject, expand horizontally // (4) c.gridx = 1; c.fill = GridBagConstraints.HORIZONTAL; c.weightx = 1; this.add(new JTextField(), c); // row 0, column 2 -\u0026amp;gt; 收件⼈： // (5) c.gridx = 2; c.fill = GridBagConstraints.NONE; c.weightx = 0; this.add(new JLabel(\u0026amp;quot;收件人：\u0026amp;quot;), c); // row 0, column 3 -\u0026amp;gt; text field for recipient, expand horizontally // (6) c.gridx = 3; c.fill = GridBagConstraints.HORIZONTAL; c.weightx = 1; this.add(new JTextField(), c); // row 1, colulmn 0 -\u0026amp;gt; email content // (7) c.gridx = 0; c.gridy = 1; c.gridwidth = 4; c.weightx = 0.0; c.weighty = 1.0; c.fill = GridBagConstraints.BOTH; this.add(new JTextArea(), c); // row 2, column 1 -\u0026amp;gt; 发送 // (8) c.gridx = 1; c.gridy = 3; c.weighty = 0; c.fill = GridBagConstraints.NONE; c.anchor = GridBagConstraints.CENTER; c.gridwidth = 1; c.ipady = 0; this.add(new JButton(\u0026amp;quot;发送\u0026amp;quot;), c); // row 2, column 3 -\u0026amp;gt; 退出; exit with success code // (9) c.gridx = 3; c.gridy = 3; c.gridwidth = 1; JButton bttn = new JButton(\u0026amp;quot;退出\u0026amp;quot;); bttn.addActionListener(e -\u0026amp;gt; System.exit(0)); this.add(bttn, c); } } MailClient\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import javax.swing.*; public class MailClient { public MailClient() { // create the main frame JFrame frame = /*(10)*/new JFrame(\u0026amp;quot;NJFU Emailer\u0026amp;quot;); // terminate the JVM when the close icon was clicked // (11) frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); // create and add the mail panel // (12) frame.add(new MailPanel()); // set the initial size of the frame, width: 600, height: 500 // (13) frame.setSize(600, 500); // display the frame // (14) frame.setVisible(true); } public static void main(String[] args) { // create the frame on the event dispatching thread instead of the // main thread. You should use Lambada // (15) SwingUtilities.invokeLater(MailClient::new); } } ","date":"2020-09-07T00:00:00Z","permalink":"http://localhost:1313/p/java%E8%80%83%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83/","title":"Java考试题参考"},{"content":"今天又ac一条水题。\n不多说直接看题\u0026mdash;\u0026ndash;\u0026gt;\nProblem Description\n人随着岁数的增长是越大越聪明还是越大越笨，这是一个值得全世界科学家思考的问题,同样的问题Eddy也一直在思考，因为他在很小的时候就知道亲和串如何判断了，但是发现，现在长大了却不知道怎么去判断亲和串了，于是他只好又再一次来请教聪明且乐于助人的你来解决这个问题。\n亲和串的定义是这样的：给定两个字符串s1和s2,如果能通过s1循环移位，使s2包含在s1中，那么我们就说s2 是s1的亲和串。\nInput\n本题有多组测试数据，每组数据的第一行包含输入字符串s1,第二行包含输入字符串s2，s1与s2的长度均小于100000。\nOutput\n如果s2是s1的亲和串，则输出\u0026quot;yes\u0026quot;，反之，输出\u0026quot;no\u0026quot;。每组测试的输出占一行。\nSample Input\nAABCD\nCDAA\nASD\nASDF\nSample Output\nyes\nno\n思路：之前在《算法》第四版中做过类似的题目，想要将s1看作一个循环的字符串，然后判断s2是否包含在其中。其实就可以将两个s1首位拼接，这样就解决了首尾分开的问题，然后直接判断s2是否在新串中即可。\nif (tmp.find(s2) != tmp.npos)\n其中这一行代码是用来判断是否是子串的，如果是子串，则find方法返回子串的位置，否则返回一个特定数（也就是npos）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026amp;lt;iostream\u0026amp;gt; #include\u0026amp;lt;string\u0026amp;gt; using namespace std; int main() { string s1, s2; while (cin \u0026amp;gt;\u0026amp;gt; s1) { cin \u0026amp;gt;\u0026amp;gt; s2; string tmp = s1 + s1; if (tmp.find(s2) != tmp.npos) cout \u0026amp;lt;\u0026amp;lt; \u0026amp;quot;yes\u0026amp;quot; \u0026amp;lt;\u0026amp;lt; endl; else cout \u0026amp;lt;\u0026amp;lt; \u0026amp;quot;no\u0026amp;quot; \u0026amp;lt;\u0026amp;lt; endl; } return 0; } ","date":"2020-08-02T00:00:00Z","permalink":"http://localhost:1313/p/hdu2203_%E4%BA%B2%E5%92%8C%E4%B8%B2/","title":"hdu2203_亲和串"},{"content":"又到了写学习记录的时候了~\n今天的主题是关于进程的，主要探讨的是进程在不同状态之间的切换问题。 通过在进程切换状态的相应代码的关键部分添加输出语句，将进程切换状态的相关信息写入文件中，以便后续的观察和数据分析。\n基础知识\n首先我们需要掌握一些基础的知识。\n在linux系统中，进程的相关信息是用结构体来保存的，包括一个进程的进程号(pid)，状态(state)，时间片(counter)等等一众信息，我们通常将这个结构体成为PCB(Process Control Block，进程控制块)。\n其中我们当前最关心的就是state了。\nstate可以取0~4这5个值，含义分别如下：\nTASK_RUNNING \u0026mdash; 0 ** 运行或就绪状态 TASK_INTERRUPTIBLE \u0026mdash; 1 ** 可中断等待 TASK_UNINTERRUPTIBLE \u0026mdash; 2 ** 不可中断等待 TASK_ZOMBIE \u0026mdash; 3 ** 僵死状态 TASK_STOPPED \u0026mdash; 4 ** 停止状态 具体含义可参见《内核》p178，此处不赘述了。\n在内核代码中，有一些函数涉及到进程状态的转换，例如：fork() \u0026ndash; 创建进程，schedual() \u0026ndash; 进程的切换，sys_sleep()进程的休眠等等。\n总结来看，我们需要做出修改的文件有fork.c, sche.c, exit.c。这3个文件都在kernel文件夹下。\n具体步骤\n具体流程可以参见实验楼，简单概括如下：\\\n编写process.c文件，其作用在于创建若干进程，并分配其占用cpu以及i/o的时间。 修改内核代码，在适当位置加上输出语句，输出所需信息至/var/process.log文件。 运行python脚本程序，根据process.log统计创建的进程具体的时间占用。 编写process.c文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #include \u0026amp;lt;unistd.h\u0026amp;gt; #include \u0026amp;lt;time.h\u0026amp;gt; #include \u0026amp;lt;sys/times.h\u0026amp;gt; #define HZ 100 void cpuio_bound(int last, int cpu_time, int io_time); int main(int argc, char * argv[]) { int pid, stat_addr; if(!(pid = fork())) /*条件，pid = 0，即在子进程中，下同*/ { cpuio_bound(10,1,1); } else { printf(\u0026amp;quot;fork %d\\n\u0026amp;quot;, pid); if(!(pid = fork())) { cpuio_bound(10,1,0); } else { printf(\u0026amp;quot;fork %d\\n\u0026amp;quot;, pid); if(!(pid = fork())) { cpuio_bound(10,0,1); } else { printf(\u0026amp;quot;fork %d\\n\u0026amp;quot;, pid); if(!(pid = fork())) { cpuio_bound(10,1,9); } else { printf(\u0026amp;quot;fork %d\\n\u0026amp;quot;, pid); } } } } wait(\u0026amp;amp;stat_addr); return 0; } /* * 此函数按照参数占用CPU和I/O时间 * last: 函数实际占用CPU和I/O的总时间，不含在就绪队列中的时间，\u0026amp;gt;=0是必须的 * cpu_time: 一次连续占用CPU的时间，\u0026amp;gt;=0是必须的 * io_time: 一次I/O消耗的时间，\u0026amp;gt;=0是必须的 * 如果last \u0026amp;gt; cpu_time + io_time，则往复多次占用CPU和I/O * 所有时间的单位为秒 */ void cpuio_bound(int last, int cpu_time, int io_time) { struct tms start_time, current_time; clock_t utime, stime; int sleep_time; while (last \u0026amp;gt; 0) { /* CPU Burst */ times(\u0026amp;amp;start_time); /* 其实只有t.tms_utime才是真正的CPU时间。但我们是在模拟一个 * 只在用户状态运行的CPU大户，就像“for(;;);”。所以把t.tms_stime * 加上很合理。*/ do { times(\u0026amp;amp;current_time); utime = current_time.tms_utime - start_time.tms_utime; stime = current_time.tms_stime - start_time.tms_stime; } while ( ( (utime + stime) / HZ ) \u0026amp;lt; cpu_time ); last -= cpu_time; if (last \u0026amp;lt;= 0 ) break; /* IO Burst */ /* 用sleep(1)模拟1秒钟的I/O操作 */ sleep_time=0; while (sleep_time \u0026amp;lt; io_time) { sleep(1); sleep_time++; } last -= sleep_time; } } 其中cpuio_bound函数是用来占用cpu的其中三个参数分别是总持续时间，cpu占用时间以及io占用时间，具体实现过程就不看了（其实是我看不懂^_^）。至于主程序，就是fork了4个新的进程，并且分别对他们调用cpuio_bound函数，以及在终端打印各自的pid号，方便观察。\n修改内核代码\n这一步需要在fork.c，sche.c，以及exit.c中添加相应的打印代码。而我们知道，在内核中是无法调用用户态函数fprintf的，因此，我们需要仿照内核态函数printk写一个用于输出到文件的函数fprintk。所幸，有现成的代码（我当然没这个能力写~）。代码可以和printk放在一起在kernel/printk.c中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 int fprintk(int fd, const char *fmt, ...) { va_list args; int count; struct file * file; struct m_inode * inode; va_start(args, fmt); count=vsprintf(logbuf, fmt, args); va_end(args); /* 如果输出到stdout或stderr，直接调用sys_write即可 */ if (fd \u0026amp;lt; 3) { __asm__(\u0026amp;quot;push %%fs\\n\\t\u0026amp;quot; \u0026amp;quot;push %%ds\\n\\t\u0026amp;quot; \u0026amp;quot;pop %%fs\\n\\t\u0026amp;quot; \u0026amp;quot;pushl %0\\n\\t\u0026amp;quot; /* 注意对于Windows环境来说，是_logbuf,下同 */ \u0026amp;quot;pushl $logbuf\\n\\t\u0026amp;quot; \u0026amp;quot;pushl %1\\n\\t\u0026amp;quot; /* 注意对于Windows环境来说，是_sys_write,下同 */ \u0026amp;quot;call sys_write\\n\\t\u0026amp;quot; \u0026amp;quot;addl $8,%%esp\\n\\t\u0026amp;quot; \u0026amp;quot;popl %0\\n\\t\u0026amp;quot; \u0026amp;quot;pop %%fs\u0026amp;quot; ::\u0026amp;quot;r\u0026amp;quot; (count),\u0026amp;quot;r\u0026amp;quot; (fd):\u0026amp;quot;ax\u0026amp;quot;,\u0026amp;quot;cx\u0026amp;quot;,\u0026amp;quot;dx\u0026amp;quot;); } else /* 假定\u0026amp;gt;=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/ { /* 从进程0的文件描述符表中得到文件句柄 */ if (!(file=task[0]-\u0026amp;gt;filp[fd])) return 0; inode=file-\u0026amp;gt;f_inode; __asm__(\u0026amp;quot;push %%fs\\n\\t\u0026amp;quot; \u0026amp;quot;push %%ds\\n\\t\u0026amp;quot; \u0026amp;quot;pop %%fs\\n\\t\u0026amp;quot; \u0026amp;quot;pushl %0\\n\\t\u0026amp;quot; \u0026amp;quot;pushl $logbuf\\n\\t\u0026amp;quot; \u0026amp;quot;pushl %1\\n\\t\u0026amp;quot; \u0026amp;quot;pushl %2\\n\\t\u0026amp;quot; \u0026amp;quot;call file_write\\n\\t\u0026amp;quot; \u0026amp;quot;addl $12,%%esp\\n\\t\u0026amp;quot; \u0026amp;quot;popl %0\\n\\t\u0026amp;quot; \u0026amp;quot;pop %%fs\u0026amp;quot; ::\u0026amp;quot;r\u0026amp;quot; (count),\u0026amp;quot;r\u0026amp;quot; (file),\u0026amp;quot;r\u0026amp;quot; (inode):\u0026amp;quot;ax\u0026amp;quot;,\u0026amp;quot;cx\u0026amp;quot;,\u0026amp;quot;dx\u0026amp;quot;); } return count; } 同样细节不深究，我们赶紧干正事。\n进程的创建 进程创建自然是fork函数来工作，深入之后发现，在sys_fork中调用的copy_process函数是创建新进程的核心步骤。该函数在kernel/fork.c文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ...... p-\u0026amp;gt;state = TASK_UNINTERRUPTIBLE; p-\u0026amp;gt;pid = last_pid; p-\u0026amp;gt;father = current-\u0026amp;gt;pid; p-\u0026amp;gt;counter = p-\u0026amp;gt;priority; p-\u0026amp;gt;signal = 0; p-\u0026amp;gt;alarm = 0; p-\u0026amp;gt;leader = 0; /* process leadership doesn\u0026amp;#39;t inherit */ p-\u0026amp;gt;utime = p-\u0026amp;gt;stime = 0; p-\u0026amp;gt;cutime = p-\u0026amp;gt;cstime = 0; p-\u0026amp;gt;start_time = jiffies; /*向log文件输出新建进程*/ fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, p-\u0026amp;gt;pid, \u0026amp;#39;N\u0026amp;#39;, jiffies); p-\u0026amp;gt;tss.back_link = 0; p-\u0026amp;gt;tss.esp0 = PAGE_SIZE + (long) p; p-\u0026amp;gt;tss.ss0 = 0x10; p-\u0026amp;gt;tss.eip = eip; p-\u0026amp;gt;tss.eflags = eflags; 这里将p-\u0026gt;state设置为TASK_UNINTERRUPTIBLE并且接下来就对p进行一系列的赋值工作，由于fork创建的子进程除了pid之外与父进程的PCB是一样的，因此这里就可以输出一条创建进程的信息，用\u0026rsquo;N\u0026rsquo;来表示新建进程。\n进程的就绪态 首先还是copy_process函数中，刚刚新建的进程，创建完成后应该变为就绪态\n1 2 3 4 5 6 7 8 ...... set_tss_desc(gdt+(nr\u0026amp;lt;\u0026amp;lt;1)+FIRST_TSS_ENTRY,\u0026amp;amp;(p-\u0026amp;gt;tss)); set_ldt_desc(gdt+(nr\u0026amp;lt;\u0026amp;lt;1)+FIRST_LDT_ENTRY,\u0026amp;amp;(p-\u0026amp;gt;ldt)); p-\u0026amp;gt;state = TASK_RUNNING; /* do this last, just in case */ /*向log文件输出就绪进程*/ fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, p-\u0026amp;gt;pid, \u0026amp;#39;J\u0026amp;#39;, jiffies); return last_pid; ...... 这里将p-\u0026gt;state改为了TASK_RUNNING，因此我们相应地输出转为就绪态的信息，用\u0026rsquo;J\u0026rsquo;来表示就绪态。\n其次是这里，在sche函数中的schedual函数。在schedule函数中，首先会检测进程的报警定时值（alarm），并将处于可中断状态且接收到信号的进程唤醒。\n1 2 3 4 5 6 7 8 9 10 11 12 13 if (*p) { if ((*p)-\u0026amp;gt;alarm \u0026amp;amp;\u0026amp;amp; (*p)-\u0026amp;gt;alarm \u0026amp;lt; jiffies) { (*p)-\u0026amp;gt;signal |= (1\u0026amp;lt;\u0026amp;lt;(SIGALRM-1)); (*p)-\u0026amp;gt;alarm = 0; } if (((*p)-\u0026amp;gt;signal \u0026amp;amp; ~(_BLOCKABLE \u0026amp;amp; (*p)-\u0026amp;gt;blocked)) \u0026amp;amp;\u0026amp;amp; (*p)-\u0026amp;gt;state==TASK_INTERRUPTIBLE) { (*p)-\u0026amp;gt;state=TASK_RUNNING; /*修改*/ fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, (*p)-\u0026amp;gt;pid, \u0026amp;#39;J\u0026amp;#39;, jiffies); } } schedual的核心功能在于进程调度，故一定有将当前进程由\u0026rsquo;R\u0026rsquo;变为\u0026rsquo;J\u0026rsquo;，以及将下一进程由\u0026rsquo;J\u0026rsquo;变为\u0026rsquo;R\u0026rsquo;的过程，添加代码如下:\n1 2 3 4 5 6 7 8 9 10 if(task[next]-\u0026amp;gt;pid != current-\u0026amp;gt;pid) /*队列中下一个非本进程*/ { if(current-\u0026amp;gt;state == TASK_RUNNING) { fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, current-\u0026amp;gt;pid, \u0026amp;#39;J\u0026amp;#39;, jiffies); } fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, task[next]-\u0026amp;gt;pid, \u0026amp;#39;R\u0026amp;#39;, jiffies); } switch_to(next); 最后是wake_up函数，用于将进程从\u0026quot;不可中断睡眠\u0026quot;中唤醒，从阻塞态\u0026rsquo;W\u0026rsquo;变为就绪态\u0026rsquo;J\u0026rsquo;：\n1 2 3 4 5 6 7 8 9 void wake_up(struct task_struct **p) { if (p \u0026amp;amp;\u0026amp;amp; *p) { (**p).state=0; /*wake_up函数直接将队列中的第一个进程唤醒*/ fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, (*p)-\u0026amp;gt;pid, \u0026amp;#39;J\u0026amp;#39;, jiffies); *p=NULL; } } 进程的阻塞态 sleep_on函数和interruptible_sleep_on函数实现进程由运行态\u0026rsquo;R\u0026rsquo;转为阻塞态\u0026rsquo;W\u0026rsquo;，而其中interruptible_sleep_on是指可以被中断唤醒的。这两个函数依旧在sche.c中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void sleep_on(struct task_struct **p) { struct task_struct *tmp; if (!p) return; if (current == \u0026amp;amp;(init_task.task)) panic(\u0026amp;quot;task[0] trying to sleep\u0026amp;quot;); tmp = *p; *p = current; current-\u0026amp;gt;state = TASK_UNINTERRUPTIBLE; /*修改*/ fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, current-\u0026amp;gt;pid, \u0026amp;#39;W\u0026amp;#39;, jiffies); schedule(); if (tmp) { tmp-\u0026amp;gt;state=0; /*0也就是TASK_RUNNING*/ /*修改*/ fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, tmp-\u0026amp;gt;pid, \u0026amp;#39;J\u0026amp;#39;, jiffies); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void interruptible_sleep_on(struct task_struct **p) { struct task_struct *tmp; if (!p) return; if (current == \u0026amp;amp;(init_task.task)) panic(\u0026amp;quot;task[0] trying to sleep\u0026amp;quot;); tmp=*p; *p=current; repeat: current-\u0026amp;gt;state = TASK_INTERRUPTIBLE; /*修改*/ fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, current-\u0026amp;gt;pid, \u0026amp;#39;W\u0026amp;#39;, jiffies); schedule(); if (*p \u0026amp;amp;\u0026amp;amp; *p != current) { (**p).state=0; /*修改*/ fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, (*p)-\u0026amp;gt;pid, \u0026amp;#39;J\u0026amp;#39;, jiffies); goto repeat; } *p=NULL; if (tmp) { tmp-\u0026amp;gt;state=0; /*修改*/ fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, tmp-\u0026amp;gt;pid, \u0026amp;#39;J\u0026amp;#39;, jiffies); } } sys_pause函数同样会将进程置为阻塞态\u0026rsquo;W\u0026rsquo;。当schedule函数发现系统中没有可执行的任务时，就会切换到0号任务，而0号任务就会循环执行sys_pause，将自己设置为可中断的阻塞态。要注意排除0号进程，因为实际上0号可以看作一直运行，所以这里将其排除在外。\n1 2 3 4 5 6 7 8 9 int sys_pause(void) { current-\u0026amp;gt;state = TASK_INTERRUPTIBLE; /*修改，当进程号为0时，会一直调用sys_pause，但实际上0号可以看作一直运行，所以这里将其排除在外*/ if(current-\u0026amp;gt;pid != 0) { fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, current-\u0026amp;gt;pid, \u0026amp;#39;W\u0026amp;#39;, jiffies); } schedule(); return 0; } 最后是exit.c文件中的sys_waitpid函数，exit.c也在kernel文件夹中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 if (flag) { if (options \u0026amp;amp; WNOHANG) return 0; current-\u0026amp;gt;state=TASK_INTERRUPTIBLE; /*修改*/ fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, current-\u0026amp;gt;pid, \u0026amp;#39;W\u0026amp;#39;, jiffies); schedule(); if (!(current-\u0026amp;gt;signal \u0026amp;amp;= ~(1\u0026amp;lt;\u0026amp;lt;(SIGCHLD-1)))) goto repeat; else return -EINTR; } return -ECHILD; 进程的退出 一个进程最终的归宿就是退出，当然退出函数一定在exit.c中，也就是do_exit函数：\n1 2 3 4 5 6 7 current-\u0026amp;gt;state = TASK_ZOMBIE; current-\u0026amp;gt;exit_code = code; /*子程序先退出，父程序再醒来，因此在tell_father之前先fprink*/ fprintk(3, \u0026amp;quot;%ld\\t%c\\t%ld\\n\u0026amp;quot;, current-\u0026amp;gt;pid, \u0026amp;#39;E\u0026amp;#39;, jiffies); tell_father(current-\u0026amp;gt;father); schedule(); return (-1); /* just to suppress warnings */ 需要在call_father之前退出子进程。\n运行process\n将linux0.11文件夹重新编译，将process.c文件通过挂载磁盘传到linux0.11中，./run运行linux0.11，完成编译工作，运行process，神奇的一幕出现了（并不）\u0026mdash;\u0026mdash;\n数据太多，截取一段process.log文件示意：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 1 N 48 1 J 48 0 J 48 1 R 48 2 N 49 2 J 49 1 W 49 2 R 49 3 N 63 3 J 64 2 J 64 3 R 64 3 W 68 2 R 68 2 E 73 1 J 73 1 R 73 4 N 74 4 J 74 1 W 74 4 R 74 5 N 106 5 J 106 4 W 107 5 R 107 4 J 109 5 E 109 4 R 109 4 W 115 0 R 115 4 J 538 4 R 538 4 W 538 0 R 538 4 J 604 4 R 604 4 W 604 0 R 604 4 J 647 4 R 647 4 W 647 0 R 647 4 J 723 4 R 723 4 W 723 0 R 723 4 J 748 4 R 748 4 W 748 0 R 748 ...... ...... 分析数据\npython脚本是提供的，这里就贴上：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 #!/usr/bin/python import sys import copy P_NULL = 0 P_NEW = 1 P_READY = 2 P_RUNNING = 4 P_WAITING = 8 P_EXIT = 16 S_STATE = 0 S_TIME = 1 HZ = 100 graph_title = r\u0026amp;quot;\u0026amp;quot;\u0026amp;quot; -----===\u0026amp;lt; COOL GRAPHIC OF SCHEDULER \u0026amp;gt;===----- [Symbol] [Meaning] ~~~~~~~~~~~~~~~~~~~~~~~~~~~ number PID or tick \u0026amp;quot;-\u0026amp;quot; New or Exit \u0026amp;quot;#\u0026amp;quot; Running \u0026amp;quot;|\u0026amp;quot; Ready \u0026amp;quot;:\u0026amp;quot; Waiting / Running with \u0026amp;quot;+\u0026amp;quot; -| Ready \\and/or Waiting -----===\u0026amp;lt; !!!!!!!!!!!!!!!!!!!!!!!!! \u0026amp;gt;===----- \u0026amp;quot;\u0026amp;quot;\u0026amp;quot; usage = \u0026amp;quot;\u0026amp;quot;\u0026amp;quot; Usage: %s /path/to/process.log [PID1] [PID2] ... [-x PID1 [PID2] ... ] [-m] [-g] Example: # Include process 6, 7, 8 and 9 in statistics only. (Unit: tick) %s /path/to/process.log 6 7 8 9 # Exclude process 0 and 1 from statistics. (Unit: tick) %s /path/to/process.log -x 0 1 # Include process 6 and 7 only and print a COOL \u0026amp;quot;graphic\u0026amp;quot;! (Unit: millisecond) %s /path/to/process.log 6 7 -m -g # Include all processes and print a COOL \u0026amp;quot;graphic\u0026amp;quot;! (Unit: tick) %s /path/to/process.log -g \u0026amp;quot;\u0026amp;quot;\u0026amp;quot; class MyError(Exception): pass class DuplicateNew(MyError): def __init__(self, pid): args = \u0026amp;quot;More than one \u0026amp;#39;N\u0026amp;#39; for process %d.\u0026amp;quot; % pid MyError.__init__(self, args) class UnknownState(MyError): def __init__(self, state): args = \u0026amp;quot;Unknown state \u0026amp;#39;%s\u0026amp;#39; found.\u0026amp;quot; % state MyError.__init__(self, args) class BadTime(MyError): def __init__(self, time): args = \u0026amp;quot;The time \u0026amp;#39;%d\u0026amp;#39; is bad. It should \u0026amp;gt;= previous line\u0026amp;#39;s time.\u0026amp;quot; % time MyError.__init__(self, args) class TaskHasExited(MyError): def __init__(self, state): args = \u0026amp;quot;The process has exited. Why it enter \u0026amp;#39;%s\u0026amp;#39; state again?\u0026amp;quot; % state MyError.__init__(self, args) class BadFormat(MyError): def __init__(self): args = \u0026amp;quot;Bad log format\u0026amp;quot; MyError.__init__(self, args) class RepeatState(MyError): def __init__(self, pid): args = \u0026amp;quot;Previous state of process %d is identical with this line.\u0026amp;quot; % (pid) MyError.__init__(self, args) class SameLine(MyError): def __init__(self): args = \u0026amp;quot;It is a clone of previous line.\u0026amp;quot; MyError.__init__(self, args) class NoNew(MyError): def __init__(self, pid, state): args = \u0026amp;quot;The first state of process %d is \u0026amp;#39;%s\u0026amp;#39;. Why not \u0026amp;#39;N\u0026amp;#39;?\u0026amp;quot; % (pid, state) MyError.__init__(self, args) class statistics: def __init__(self, pool, include, exclude): if include: self.pool = process_pool() for process in pool: if process.getpid() in include: self.pool.add(process) else: self.pool = copy.copy(pool) if exclude: for pid in exclude: if self.pool.get_process(pid): self.pool.remove(pid) def list_pid(self): l = [] for process in self.pool: l.append(process.getpid()) return l def average_turnaround(self): if len(self.pool) == 0: return 0 sum = 0 for process in self.pool: sum += process.turnaround_time() return float(sum) / len(self.pool) def average_waiting(self): if len(self.pool) == 0: return 0 sum = 0 for process in self.pool: sum += process.waiting_time() return float(sum) / len(self.pool) def begin_time(self): begin = 0xEFFFFF for p in self.pool: if p.begin_time() \u0026amp;lt; begin: begin = p.begin_time() return begin def end_time(self): end = 0 for p in self.pool: if p.end_time() \u0026amp;gt; end: end = p.end_time() return end def throughput(self): return len(self.pool) * HZ / float(self.end_time() - self.begin_time()) def print_graphic(self): begin = self.begin_time() end = self.end_time() print graph_title for i in range(begin, end+1): line = \u0026amp;quot;%5d \u0026amp;quot; % i for p in self.pool: state = p.get_state(i) if state \u0026amp;amp; P_NEW: line += \u0026amp;quot;-\u0026amp;quot; elif state == P_READY or state == P_READY | P_WAITING: line += \u0026amp;quot;|\u0026amp;quot; elif state == P_RUNNING: line += \u0026amp;quot;#\u0026amp;quot; elif state == P_WAITING: line += \u0026amp;quot;:\u0026amp;quot; elif state \u0026amp;amp; P_EXIT: line += \u0026amp;quot;-\u0026amp;quot; elif state == P_NULL: line += \u0026amp;quot; \u0026amp;quot; elif state \u0026amp;amp; P_RUNNING: line += \u0026amp;quot;+\u0026amp;quot; else: assert False if p.get_state(i-1) != state and state != P_NULL: line += \u0026amp;quot;%-3d\u0026amp;quot; % p.getpid() else: line += \u0026amp;quot; \u0026amp;quot; print line class process_pool: def __init__(self): self.list = [] def get_process(self, pid): for process in self.list: if process.getpid() == pid: return process return None def remove(self, pid): for process in self.list: if process.getpid() == pid: self.list.remove(process) def new(self, pid, time): p = self.get_process(pid) if p: if pid != 0: raise DuplicateNew(pid) else: p.states=[(P_NEW, time)] else: p = process(pid, time) self.list.append(p) return p def add(self, p): self.list.append(p) def __len__(self): return len(self.list) def __iter__(self): return iter(self.list) class process: def __init__(self, pid, time): self.pid = pid self.states = [(P_NEW, time)] def getpid(self): return self.pid def change_state(self, state, time): last_state, last_time = self.states[-1] if state == P_NEW: raise DuplicateNew(pid) if time \u0026amp;lt; last_time: raise BadTime(time) if last_state == P_EXIT: raise TaskHasExited(state) if last_state == state and self.pid != 0: # task 0 can have duplicate state raise RepeatState(self.pid) self.states.append((state, time)) def get_state(self, time): rval = P_NULL combo = P_NULL if self.begin_time() \u0026amp;lt;= time \u0026amp;lt;= self.end_time(): for state, s_time in self.states: if s_time \u0026amp;lt; time: rval = state elif s_time == time: combo |= state else: break if combo: rval = combo return rval def turnaround_time(self): return self.states[-1][S_TIME] - self.states[0][S_TIME] def waiting_time(self): return self.state_last_time(P_READY) def cpu_time(self): return self.state_last_time(P_RUNNING) def io_time(self): return self.state_last_time(P_WAITING) def state_last_time(self, state): time = 0 state_begin = 0 for s,t in self.states: if s == state: state_begin = t elif state_begin != 0: assert state_begin \u0026amp;lt;= t time += t - state_begin state_begin = 0 return time def begin_time(self): return self.states[0][S_TIME] def end_time(self): return self.states[-1][S_TIME] # Enter point if len(sys.argv) \u0026amp;lt; 2: print usage.replace(\u0026amp;quot;%s\u0026amp;quot;, sys.argv[0]) sys.exit(0) # parse arguments include = [] exclude = [] unit_ms = False graphic = False ex_mark = False try: for arg in sys.argv[2:]: if arg == \u0026amp;#39;-m\u0026amp;#39;: unit_ms = True continue if arg == \u0026amp;#39;-g\u0026amp;#39;: graphic = True continue if not ex_mark: if arg == \u0026amp;#39;-x\u0026amp;#39;: ex_mark = True else: include.append(int(arg)) else: exclude.append(int(arg)) except ValueError: print \u0026amp;quot;Bad argument \u0026amp;#39;%s\u0026amp;#39;\u0026amp;quot; % arg sys.exit(-1) # parse log file and construct processes processes = process_pool() f = open(sys.argv[1], \u0026amp;quot;r\u0026amp;quot;) # Patch process 0\u0026amp;#39;s New \u0026amp;amp; Run state processes.new(0, 40).change_state(P_RUNNING, 40) try: prev_time = 0 prev_line = \u0026amp;quot;\u0026amp;quot; for lineno, line in enumerate(f): if line == prev_line: raise SameLine prev_line = line fields = line.split(\u0026amp;quot;\\t\u0026amp;quot;) if len(fields) != 3: raise BadFormat pid = int(fields[0]) s = fields[1].upper() time = int(fields[2]) if time \u0026amp;lt; prev_time: raise BadTime(time) prev_time = time p = processes.get_process(pid) state = P_NULL if s == \u0026amp;#39;N\u0026amp;#39;: processes.new(pid, time) elif s == \u0026amp;#39;J\u0026amp;#39;: state = P_READY elif s == \u0026amp;#39;R\u0026amp;#39;: state = P_RUNNING elif s == \u0026amp;#39;W\u0026amp;#39;: state = P_WAITING elif s == \u0026amp;#39;E\u0026amp;#39;: state = P_EXIT else: raise UnknownState(s) if state != P_NULL: if not p: raise NoNew(pid, s) p.change_state(state, time) except MyError, err: print \u0026amp;quot;Error at line %d: %s\u0026amp;quot; % (lineno+1, err) sys.exit(0) # Stats stats = statistics(processes, include, exclude) att = stats.average_turnaround() awt = stats.average_waiting() if unit_ms: unit = \u0026amp;quot;ms\u0026amp;quot; att *= 1000/HZ awt *= 1000/HZ else: unit = \u0026amp;quot;tick\u0026amp;quot; print \u0026amp;quot;(Unit: %s)\u0026amp;quot; % unit print \u0026amp;quot;Process Turnaround Waiting CPU Burst I/O Burst\u0026amp;quot; for pid in stats.list_pid(): p = processes.get_process(pid) tt = p.turnaround_time() wt = p.waiting_time() cpu = p.cpu_time() io = p.io_time() if unit_ms: print \u0026amp;quot;%7d %10d %7d %9d %9d\u0026amp;quot; % (pid, tt*1000/HZ, wt*1000/HZ, cpu*1000/HZ, io*1000/HZ) else: print \u0026amp;quot;%7d %10d %7d %9d %9d\u0026amp;quot; % (pid, tt, wt, cpu, io) print \u0026amp;quot;Average: %10.2f %7.2f\u0026amp;quot; % (att, awt) print \u0026amp;quot;Throughout: %.2f/s\u0026amp;quot; % (stats.throughput()) if graphic: stats.print_graphic() 最后运行结果是这样滴~\n拜拜了您嘞~（累瘫）\\\n","date":"2020-07-30T00:00:00Z","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/","title":"操作系统实验学习记录（3）"},{"content":"操作系统实验2，和第一次实验时间隔得稍微久了那么亿点点。。不要在意这些细节，赶紧进入正题（掩盖自己懒的事实）\\\n首先阐明本实验的目的：实现系统调用\n要实现一个系统调用，首先得明白从用户输入命令，到系统调用相应的函数，最终完成功能，中间到底经历了怎样的过程。\n真正的系统调用实现在内核中，操作系统向用户提供了API（Application Programming Interface），这些API并不实现系统调用的功能，而是去调用真正的系统调用，以实现相应的功能。\n用户程序 API 系统调用 大致上是从上到下的这样一种顺序，即：用户程序中调用操作系统提供的API，而API进一步调用内核中的系统调用来实现功能。\n下面以lib/close.c为例，来具体看一看其代码实现：\n1 2 3 4 5 6 7 8 9 10 /* * linux/lib/close.c * * (C) 1991 Linus Torvalds */ #define __LIBRARY__ #include \u0026amp;lt;unistd.h\u0026amp;gt; _syscall1(int,close,int,fd) 除去注释，宏定义和头文件包含，核心语句就是\n1 _syscall1(int,close,int,fd) 显然这是一个宏，打开close.c中唯一包含的头文件(include/unistd.h)，可以找到\n1 2 3 4 5 6 7 8 9 10 11 12 #define _syscall1(type,name,atype,a) \\ type name(atype a) \\ { \\ long __res; \\ __asm__ volatile (\u0026amp;quot;int $0x80\u0026amp;quot; \\ : \u0026amp;quot;=a\u0026amp;quot; (__res) \\ : \u0026amp;quot;0\u0026amp;quot; (__NR_##name),\u0026amp;quot;b\u0026amp;quot; ((long)(a))); \\ if (__res \u0026amp;gt;= 0) \\ return (type) __res; \\ errno = -__res; \\ return -1; \\ } 那么将close.c中的宏展开就是这样\n1 2 3 4 5 6 7 8 9 10 11 int close(int fd) { long __res; __asm__ volatile (\u0026amp;quot;int $0x80\u0026amp;quot; : \u0026amp;quot;=a\u0026amp;quot; (__res) : \u0026amp;quot;0\u0026amp;quot; (__NR_close),\u0026amp;quot;b\u0026amp;quot; ((long)(fd))); if (__res \u0026amp;gt;= 0) return (int) __res; errno = -__res; return -1; } 这是一个c语言的函数，在函数体中有一段内嵌汇编，可以看出，NR_close传给eax，fd强转为long后传给ebx，这二者作为输入；核心的汇编语句是int $0x80，即调用0x80号中断，由此可见，api本质上是通过中断的方式去调用系统调用的。\n又注意到NR_close并不在函数体中定义，那么在unistd.h这个文件中往前寻找，果然：\n1 2 3 4 5 6 ... #define __NR_open 5 #define __NR_close 6 #define __NR_waitpid 7 #define __NR_creat 8 ... 原来__NR_close也是宏，定义为6，之前说过它被传递给eax，这代表这close在中断向量表中的位置为6。\n至此，我们理清了api做的事情：根据相应的系统调用号，发出中断请求int 0x80。\n下一步就要研究中断指令int 0x80究竟干了一件什么事。\n在内核初始化时，调用了这样一个函数\n1 2 3 4 5 void sched_init(void) { // …… set_system_gate(0x80,\u0026amp;amp;system_call); } 实际上就是将system_call的地址写入0x80的中断描述符表（Interrupt Descriptor Table，IDT），使得中断0x80发生时，会自动调用system_call函数，此函数在kernel/system_call.s中，是一个汇编文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 !…… ! # 这是系统调用总数。如果增删了系统调用，必须做相应修改 nr_system_calls = 72 !…… .globl system_call .align 2 system_call: ! # 检查系统调用编号是否在合法范围内 cmpl \\$nr_system_calls-1,%eax ja bad_sys_call push %ds push %es push %fs pushl %edx pushl %ecx ! # push %ebx,%ecx,%edx，是传递给系统调用的参数 pushl %ebx ! # 让ds, es指向GDT，内核地址空间 movl $0x10,%edx mov %dx,%ds mov %dx,%es movl $0x17,%edx ! # 让fs指向LDT，用户地址空间 mov %dx,%fs call sys_call_table(,%eax,4) pushl %eax movl current,%eax cmpl $0,state(%eax) jne reschedule cmpl $0,counter(%eax) je reschedule 其中call sys_call_table(,%eax,4)是关键，这个寻址方式实际上表达了call sys_call_table + 4 * %eax，而eax中实际放的是系统调用号，也就是说这句话是根据调用号，在sys_call_table表中找到对应的系统调用函数，然后调用它。至于为什么是4 * %eax呢，因为32为的系统，内存地址是32位（4 Byte）的。\n这个表的位置在include/linux/sys.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... extern int sys_open(); extern int sys_close(); extern int sys_waitpid(); extern int sys_creat(); ... fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read, sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link, sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod, sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount, sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm, sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access, sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir, sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid, sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys, sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit, sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid, sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask, sys_setreuid,sys_setregid, sys_iam, sys_whoami }; 前面是系统调用函数的extern声明，最后则是这个表啦！\n最为核心的，也就是close系统调用本体，sys_close函数，位于fs/open.c文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int sys_close(unsigned int fd) { struct file * filp; if (fd \u0026amp;gt;= NR_OPEN) return -EINVAL; current-\u0026amp;gt;close_on_exec \u0026amp;amp;= ~(1\u0026amp;lt;\u0026amp;lt;fd); if (!(filp = current-\u0026amp;gt;filp[fd])) return -EINVAL; current-\u0026amp;gt;filp[fd] = NULL; if (filp-\u0026amp;gt;f_count == 0) panic(\u0026amp;quot;Close: file count is 0\u0026amp;quot;); if (--filp-\u0026amp;gt;f_count) return (0); iput(filp-\u0026amp;gt;f_inode); return (0); } 细节就不分析了，总之就是在做close该做的事情。\n好了！到此为止，我以close函数为例，由表面的api一步步深挖到最核心的系统调用实现。这样应该理清了一个系统调用的具体实现和调用过程。下一步就是关键的自己动手做啦！\n(分割线好像不太明显。。)\n我们的目标是实现iam和whoami\n首先列举一下需要做的事情：\n写sys_iam()和sys_whoami()两个系统调用函数。（废话） 定义iam和whoami的API接口。 修改一些文件，比如添加相应的调用号的宏定义，更改调用总数等。 写应用程序测试系统调用是否成功。 定义API\n在kernel文件夹内建立who.c文件，并编写以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026amp;lt;unistd.h\u0026amp;gt; #include \u0026amp;lt;errno.h\u0026amp;gt; #include \u0026amp;lt;asm/segment.h\u0026amp;gt; char a[100]; /*用来保存name*/ int sys_iam(const char * name) { int i = 0; /*循环存放到字符串尾*/ while((get_fs_byte(name + i)) != \u0026amp;#39;\\0\u0026amp;#39;) { i++; } if(i \u0026amp;gt;= 24) { return -EINVAL; } i = 0; while((get_fs_byte(name + i)) != \u0026amp;#39;\\0\u0026amp;#39;) { a[i] = get_fs_byte(name + i); i++; } printk(\u0026amp;quot;len(a):%d\u0026amp;quot;, i); return i; } int sys_whoami(char * name, unsigned int size) { int i = 0; while(a[i] != \u0026amp;#39;\\0\u0026amp;#39;) { i++; } if(i \u0026amp;gt; size) { return -1; } i = 0; while(a[i] != \u0026amp;#39;\\0\u0026amp;#39;) { put_fs_byte(a[i], name + i); i++; } return i; } 简单分析一下\nchar a[100]; /用来保存name/\n采用char[]数组来存放用户的name\n在sys_iam函数中，先检查name的字符数，超过规定的个数则返回错误代码，符合要求则再次循环，将其存入a。\n而在sys_whoami函数中，同样检查字符个数，符合要求后调用put_fs_byte函数，将a[]中的字符串复制到name中，利用指针返回。\n用户测试程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #define __LIBRARY__ #include\u0026amp;lt;unistd.h\u0026amp;gt; #include\u0026amp;lt;stdio.h\u0026amp;gt; #include\u0026amp;lt;errno.h\u0026amp;gt; /* 功能:用户态文件,测试系统调用iam() */ /* 系统调用: */ /* 第一个是函数返回值类型，第二个为函数名，第三个是参数1的数据类型，第四个是参数1的名称，依次类推 */ _syscall1(int,iam,const char*,myname) #define NAMELEN 50 /* 定义最大长度为50 */ char myname[NAMELEN] = {0}; /* 用户态下，存储名字,并且要初始化 */ /* argc是命令行参数的个数，argv存储了所有的命令行输入的所有参数的值 */ /* 比如./iam warm-like-spring :得到argc=2,argv[0]=./iam,argv[1]=warm-like-spring */ int main(int argc, char* argv[]) { int res = 0; /* 用于接受系统调用后的返回值 */ unsigned int namelen = 0; /* 名字的实际长度 */ if(argc \u0026amp;lt; 2){ printf(\u0026amp;quot;Input arguments is less!\\n\u0026amp;quot;); return -1; } else { while(argv[1][namelen] != \u0026amp;#39;\\0\u0026amp;#39;){ /* 读取并拷贝main参数接收的输入名字字符串 */ myname[namelen] = argv[1][namelen]; ++namelen; } printf(\u0026amp;quot;before systemcall, myname: %s, namelen: %d in iam.c\\n\u0026amp;quot;,myname,namelen); res = iam(myname); /* 传递拷贝的参数进行调用 */ } if(res == -1) printf(\u0026amp;quot;systemcall have bug, res:%d, errno:%d\\n\u0026amp;quot;,res,errno); /* 打印对应的错误信息码 */ else printf(\u0026amp;quot;systemcall success, res:%d\\n\u0026amp;quot;,res); return 0; } ———————————————— 版权声明：本文为CSDN博主「嘻嘻作者哈哈」的原创文章 原文链接：https://blog.csdn.net/weixin_43971252/article/details/89714559\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/td\u0026gt; 这里偷个懒，原博主写得很详细，就直接粘了他的代码过来。核心部分一个是上面通过宏，定义了iam的API，其次就是下面的测试main函数，用来调用API以及产生测试输出。\n下面同样给出whoami.c的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #define __LIBRARY__ #include\u0026amp;lt;unistd.h\u0026amp;gt; #include\u0026amp;lt;stdio.h\u0026amp;gt; #include\u0026amp;lt;errno.h\u0026amp;gt; /* 功能:用户态文件,测试系统调用whoami() */ _syscall2(int, whoami, char*, myname, unsigned int, size) #define SIZE 23 int main(int argc, char** argv) { char myname[SIZE+1] = {0}; /* 定义初始化 */ unsigned int res = 0; res = whoami(myname, SIZE+1); if(res == -1) printf(\u0026amp;quot;systemcall have bug, res:%d, errno:%d\\n\u0026amp;quot;,res,errno); else{ printf(\u0026amp;quot;systemcall success.\\n\u0026amp;quot;); /*如果要执行testlab2.sh来测试,要把这一行注释掉*/ printf(\u0026amp;quot;%s\\n\u0026amp;quot;,myname); } return 0; } ———————————————— 版权声明：本文为CSDN博主「嘻嘻作者哈哈」的原创文章 原文链接：https://blog.csdn.net/weixin_43971252/article/details/89714559\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/td\u0026gt; 值得注意的是，这两个文件是用户的测试程序，所以需要先挂载，以便宿主机和虚拟机之间交换文件\nsudo ./mount-hdc\n将这两个文件放在hdc/usr/root文件夹下，这也就是linux0.11启动后用户所在的根目录，方便直接进行编译操作。\n中间文件修改\n最外和最内的文件都写好了，下面需要修改一些中间文件，比如添加系统调用号，以及函数声明等来使得系统调用可以顺利进行。\\\n添加系统调用号的宏定义\\ 值得注意的是，不能直接修改include/unistd.h文件，因为在linux0.11系统中编译c文件，默认的头文件都在usr/include文件夹下，所以仍需要在挂载状态下，进入hdc/usr/include/unistd.h进行修改。\n1 2 #define __NR_iam 72 #define __NR_whoami 73\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/td\u0026gt; 由于本来有72个系统调用，编号到71，故在最后补上两个我们自己写的。\n修改系统调用总数 打开kernel/system_call.s文件\n1 2 ! # 这是系统调用总数。如果增删了系统调用，必须做相应修改 nr_system_calls = 72 找到这一行，由于我们添加了两个系统调用，故将72改为74.\n修改sys_call_table函数表 + 添加函数声明 打开include/linux/sys.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read, sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link, sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod, sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount, sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm, sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access, sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir, sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid, sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys, sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit, sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid, sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask, sys_setreuid,sys_setregid, sys_iam, sys_whoami }; 在最后添加上我们写的系统调用的名字。同时需要在前面也补上它们的声明\n1 2 extern int sys_whoami(); extern int sys_iam(); 修改Makefile文件\n修改Makefile文件，Makefile文件在各个文件夹下都有出现，主要是用来指导编译工作的，具体我就不太了解啦~\n除去用户测试文件，我们只添加了一个who.c文件，路径是kernel/who.c，所以只需要修改kernel文件夹下的Makefile文件。\n1 2 3 OBJS = sched.o system_call.o traps.o asm.o fork.o \\ panic.o printk.o vsprintf.o sys.o exit.o \\ signal.o mktime.o who.o 在最后添加who.o\n1 2 3 4 5 6 7 ### Dependencies: who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.h exit.s exit.o: exit.c ../include/errno.h ../include/signal.h \\ ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \\ ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \\ ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \\ ../include/asm/segment.h 添加\nwho.s who.o: who.c ../include/linux/kernel.h ../include/unistd.h\n测试\n终于到了检验成果的时候了！！！\n./run\ngcc -o iam iam.c -Wall\ngcc -o whoami whoami.c -Wall\n当当当当~\n顺利出现了预期的结果~\\\n","date":"2020-07-22T00:00:00Z","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/","title":"操作系统实验学习记录（2）"},{"content":"2214_函数图像\nProblem Description\n在数学中，我们经常会遇到，关于函数的问题，在画一些函数的图像的时候，最长用的方法就是\u0026quot;描点法\u0026quot;。\n\u0026ldquo;描点法\u0026rdquo; 的具体步骤如下：\n计算出函数在某些特定点的值 在坐标系中标记出这些点 用平滑的曲线连接这些点 但是，在实际的操作中，我们会发现，前两部的计算量还是相当大的，所以，我们想编写一个程序，能够在一个坐标系中直接的画出各点。\n为了简化这个问题，给出如下y 关于x 的函数表达式\ny=a1x^b1+a2x^b2+a3x^b3+\u0026hellip;+anx^bn\n表达式不超过5项，并且 其中每项的系数 -10 \u0026lt; a \u0026lt;10 ， x的指数 0 \u0026lt;= b \u0026lt; 5\n表达式中，所有的字符串都是以 \u0026ldquo;y=\u0026rdquo; 开始的 ，在之后的字符串中只含有x ，+ ， - ， 0~9 这些字符，不含有空格。无非法表达式输入。\n特别的：\n当x 的指数为1时，省略指数, 例如: y = 2x^1 应表示为 y = 2x\n当x 的指数为0时，省略指数和x, 例如: y = 3x^3+2x^0 应表示为 y = 3x^3+2\n当x 的系数为负时, 例如: y = 3x^2 + (-1) x 应表示为 y = 3x^2 \u0026ndash; x , y = 2x + (-2) 应表示为 y = 2x - 2\n在如下坐标系中画出，x属于[-30,30] 所对应y属于[-30,30]的图像。\nInput\n多组数据输入，每组数据的第一行给出一个n (1\u0026lt;=n \u0026lt;= 26) ，接下来的n行，每行有一个函数的表达式。\nOutput\n对于每组输入数据，在第一行输出，\u0026ldquo;Case:#\u0026rdquo; ，# 代表当前的组号。 画出该函数的图像 x取值[-30,30]时， y在 [-30,30]内的点 。对于给出的n个表达式，依次用字母a-z表示每个函数图像上的的所有点。两个图像的交点 或者 图像与坐标轴的交点 用 \u0026lsquo;.\u0026rsquo; 表示。输出格式如下所示。各组之间无空行。\nSample Input\n2\ny=-x-1\ny=x^4+1-x^3\nSample Output\n分析：\n题目的核心部分在于计算给定字符串的结果，可以将字符串根据+-号分割成各个部分，每个部分分别计算，最后求和即可得到最终结果。\n我采用了char[62][62]的二维数组来存放各个位置上的字符，通过初始化，将坐标轴以及箭头和xy等字符填入，其余部分填入空格。\n主函数内对于相应的x，从0开始分别向左右递减或递增，对于每个x，调用函数，算出相应的y值，并填入数组中，交叉部分按题目要求填入\u0026rsquo;.\u0026rsquo;。\n最终一组数据处理完后进行逐行打印。\n没想到，这一步卡了我好久。。。\n我满心欢喜做出答案提交系统，系统却给了我一个\nPresentation Error\n我不解地百度，发现这个错误一般是由于不注意的空格，空行等造成的。于是我开始仔细对比，包括看看别人的代码输出与我的有何差别，可是看来看去完全一致。\n命令行窗口是看不出空格的差别的，因为鼠标拖动可以选中任意的空白位置，压根不知道此处是不是有空格。\n直到我偶然发现题目给的样例输出，最右边一列，除了\u0026gt;和下一行的x外，剩下的压根就没有空格填充，这才碰运气般找到了出路。\n下面就给出代码吧。。我太难了！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 #include\u0026amp;lt;iostream\u0026amp;gt; #include\u0026amp;lt;string\u0026amp;gt; using namespace std; int ditcul(string s, int i) { int res = 0, sum; for (int j = 2; j \u0026amp;lt; s.length(); ) //从2开始，前两个字符是\u0026amp;#39;y=\u0026amp;#39; { sum = 0; if (s[j] == \u0026amp;#39;-\u0026amp;#39;) { if (s[j + 1] \u0026amp;gt;= \u0026amp;#39;0\u0026amp;#39; \u0026amp;amp;\u0026amp;amp; s[j + 1] \u0026amp;lt;= \u0026amp;#39;9\u0026amp;#39;) { if (s[j + 2] == \u0026amp;#39;x\u0026amp;#39;) { if (s[j + 3] == \u0026amp;#39;^\u0026amp;#39;) { sum = -(s[j + 1] - \u0026amp;#39;0\u0026amp;#39;) * pow(i, s[j + 4] - \u0026amp;#39;0\u0026amp;#39;); j = j + 5; } else //指数为1 { sum = -(s[j + 1] - \u0026amp;#39;0\u0026amp;#39;) * i; j = j + 3; } } else //指数为0 { sum = -(s[j + 1] - \u0026amp;#39;0\u0026amp;#39;); j = j + 2; } } else //系数省略 { if (s[j + 1] == \u0026amp;#39;x\u0026amp;#39;) { if (s[j + 2] == \u0026amp;#39;^\u0026amp;#39;) { sum = -pow(i, s[j + 3] - \u0026amp;#39;0\u0026amp;#39;); j = j + 4; } else //指数为1 { sum = -i; j = j + 2; } } //由于系数省略，所以指数不可能为0 //else //指数为0 //{ // sum = -1; // j = j + 2; //} } } else if (s[j] == \u0026amp;#39;+\u0026amp;#39;) //正数 { if (s[j + 1] \u0026amp;gt;= \u0026amp;#39;0\u0026amp;#39; \u0026amp;amp;\u0026amp;amp; s[j + 1] \u0026amp;lt;= \u0026amp;#39;9\u0026amp;#39;) { if (s[j + 2] == \u0026amp;#39;x\u0026amp;#39;) { if (s[j + 3] == \u0026amp;#39;^\u0026amp;#39;) { sum = (s[j + 1] - \u0026amp;#39;0\u0026amp;#39;) * pow(i, s[j + 4] - \u0026amp;#39;0\u0026amp;#39;); j = j + 5; } else //指数为1 { sum = (s[j + 1] - \u0026amp;#39;0\u0026amp;#39;) * i; j = j + 3; } } else //指数为0 { sum = s[j + 1] - \u0026amp;#39;0\u0026amp;#39;; j = j + 2; } } else //系数省略 { if (s[j + 1] == \u0026amp;#39;x\u0026amp;#39;) { if (s[j + 2] == \u0026amp;#39;^\u0026amp;#39;) { sum = pow(i, s[j + 3] - \u0026amp;#39;0\u0026amp;#39;); j = j + 4; } else //指数为1 { sum = i; j = j + 2; } } //由于系数省略，所以指数不可能为0 //else //指数为0 //{ // sum = 1; // j = j + 2; //} } } else //位于开头，前无正负号 { if (s[j] \u0026amp;gt;= \u0026amp;#39;0\u0026amp;#39; \u0026amp;amp;\u0026amp;amp; s[j] \u0026amp;lt;= \u0026amp;#39;9\u0026amp;#39;) { if (s[j + 1] == \u0026amp;#39;x\u0026amp;#39;) { if (s[j + 2] == \u0026amp;#39;^\u0026amp;#39;) { sum = (s[j] - \u0026amp;#39;0\u0026amp;#39;) * pow(i, s[j + 3] - \u0026amp;#39;0\u0026amp;#39;); j = j + 4; } else //指数为1 { sum = (s[j] - \u0026amp;#39;0\u0026amp;#39;) * i; j = j + 2; } } else //指数为0 { sum = s[j] - \u0026amp;#39;0\u0026amp;#39;; j = j + 1; } } else //系数省略 { if (s[j] == \u0026amp;#39;x\u0026amp;#39;) { if (s[j + 1] == \u0026amp;#39;^\u0026amp;#39;) { sum = pow(i, s[j + 2] - \u0026amp;#39;0\u0026amp;#39;); j = j + 3; } else //指数为1 { sum = i; j = j + 1; } } } } res += sum; } return res; } void pic_init(char pic[62][62]) { for (int i = 0; i \u0026amp;lt; 62; i++) { for (int j = 0; j \u0026amp;lt; 62; j++) { if (i == 31 \u0026amp;amp;\u0026amp;amp; j == 30) pic[i][j] = \u0026amp;#39;+\u0026amp;#39;; else if (i == 0 \u0026amp;amp;\u0026amp;amp; j == 29) pic[i][j] = \u0026amp;#39;y\u0026amp;#39;; else if (i == 0 \u0026amp;amp;\u0026amp;amp; j == 30) pic[i][j] = \u0026amp;#39;^\u0026amp;#39;; else if (i != 0 \u0026amp;amp;\u0026amp;amp; j == 30) pic[i][j] = \u0026amp;#39;|\u0026amp;#39;; else if (i == 31 \u0026amp;amp;\u0026amp;amp; j != 61) pic[i][j] = \u0026amp;#39;-\u0026amp;#39;; else if (i == 31) pic[i][j] = \u0026amp;#39;\u0026amp;gt;\u0026amp;#39;; else if (i == 32 \u0026amp;amp;\u0026amp;amp; j == 61) pic[i][j] = \u0026amp;#39;x\u0026amp;#39;; else pic[i][j] = \u0026amp;#39; \u0026amp;#39;; } } } void pic_print(char pic[62][62]) { for (int i = 0; i \u0026amp;lt; 62; i++) { for (int j = 0; j \u0026amp;lt; 62; j++) { if (j == 61) { if (pic[i][j] == \u0026amp;#39;\u0026amp;gt;\u0026amp;#39; || pic[i][j] == \u0026amp;#39;x\u0026amp;#39;) cout \u0026amp;lt;\u0026amp;lt; pic[i][j]; } else cout \u0026amp;lt;\u0026amp;lt; pic[i][j]; } cout \u0026amp;lt;\u0026amp;lt; endl; } } int main() { char pic[62][62]; //存放绘图的内容 //初始化坐标图 pic_init(pic); int t, count = 1; while (cin \u0026amp;gt;\u0026amp;gt; t) { string s; for (int i = 0; i \u0026amp;lt; t; i++) { cin \u0026amp;gt;\u0026amp;gt; s; for (int j = 30; j \u0026amp;gt;= 0; j--) { int res = ditcul(s, j - 30); if (res \u0026amp;lt;= 30 \u0026amp;amp;\u0026amp;amp; res \u0026amp;gt;= -30) { if (pic[31 - res][j] != \u0026amp;#39; \u0026amp;#39;) { pic[31 - res][j] = \u0026amp;#39;.\u0026amp;#39;; } else { pic[31 - res][j] = \u0026amp;#39;a\u0026amp;#39; + i; } } else break; } for (int j = 30; j \u0026amp;lt;= 60; j++) { int res = ditcul(s, j - 30); if (res \u0026amp;lt;= 30 \u0026amp;amp;\u0026amp;amp; res \u0026amp;gt;= -30) { if (pic[31 - res][j] != \u0026amp;#39; \u0026amp;#39;) { pic[31 - res][j] = \u0026amp;#39;.\u0026amp;#39;; } else { pic[31 - res][j] = \u0026amp;#39;a\u0026amp;#39; + i; } } else break; } } cout \u0026amp;lt;\u0026amp;lt; \u0026amp;quot;Case:\u0026amp;quot; \u0026amp;lt;\u0026amp;lt; count++ \u0026amp;lt;\u0026amp;lt; endl; pic_print(pic); pic_init(pic); } return 0; } 输出格式太折磨人，溜了溜了。。\\\n","date":"2020-07-18T00:00:00Z","permalink":"http://localhost:1313/p/hdu2214_%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F/","title":"hdu2214_函数图像"},{"content":"终于考完了驾照，先开心一会儿~\n但是这也代表划水的日子到此为止了，大家都在不断努力，我也不能落后太多。\\\n2211_杀人游戏\nProblem Description\n1 不知道你是否玩过杀人游戏，这里的杀人游戏可没有法官，警察之类的人，只有土匪，现在已知有N个土匪站在一排，每个土匪都有一个编号，从1到N，每次杀人时给定一个K值，从还活着的土匪中，编号从小到大的找到K个人，然后杀掉，继续往下，直到找遍，然后继续从剩下的土匪中，编号从小到大找到第K个活着的土匪，然后杀掉。比如，现在有10个土匪，K为3，第一次杀掉3，6，9号的土匪，第二次杀掉4，8号土匪，第三次杀掉5号土匪，第四次杀掉7号土匪，第五次杀掉10号土匪，我们看到10号土匪是最后一个被杀掉的（从1到K-1的土匪运气好，不会被杀！）。现在给定你一个N和一个K，问你最后一个被杀掉的土匪的编号是多少。 Input\n1 第一行有一个T（T\u0026amp;lt;=10000），接下来有T组数据，每组中包含一个N（N\u0026amp;lt;2^31）和一个K（3\u0026amp;lt;=K\u0026amp;lt;=100\u0026amp;amp;\u0026amp;amp;K\u0026amp;lt;N）。 Output\n1 对于每组数据，输出最后被杀的土匪的编号。 没有做过的oj题型不能硬想，秉承着这个思想，我去搜索学习了相关的类题（真的不是偷懒orz）\n其实相关的题目之前学校里做过，本质上是约瑟夫环类型的题目，但当时没有要求时间空间，采用的是最容易想到但也最慢的循环链表法。当然本题并不是循环，但原理差不多，可以采用递归的思路来解决，下面详细地分析一哈。\n从最后一轮开始分析，比如每次循环的k为3，最后一个被杀的编号一定就是k，也就是3。\n往前推一轮，这个人的编号就变成了4。为什么呢？此人前面有两个人，而数到3就会被杀，那么如果最后一轮此人要在第3，则上一轮他前面还有一个人。\n推广到一般情况，在某一轮此人的编号假设是x，那么上一轮他的编号是多少呢？其实很简单，由于前面有x-1个人，而每隔k-1个人就会被杀掉1个，那么前一轮此人之前一共被杀了(x-1) / (k-1)个人，就是数这一轮前面有多少个k-1人组，每个k-1人组就曾经被杀1人（上一轮是k人组）。由此就能得到最重要的递推关系式：\n1 2 3 f(n,k) = (next-1) / (k-1) + next 其中next = f(n-n/k,k) f(n,k)表示在剩余n个人的情况下，最后被杀者所在的编号，next表示下一轮他所在的编号。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026amp;lt;iostream\u0026amp;gt; using namespace std; int kill(int n, int k) { if (n == k) return k; int next = kill(n - n / k, k); return (next - 1) / (k - 1) + next; } int main() { int t, n, k; //问题组数 cin \u0026gt;\u0026gt; t; int res; for (int i = 0; i \u0026amp;lt; t; i++) { cin \u0026amp;gt;\u0026amp;gt; n \u0026amp;gt;\u0026amp;gt; k; res = kill(n, k); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } return 0; } 在我思考的时候想过如果被杀的不是最后一个编号（当然事实也是如此），会不会出问题，但事实上不会，因为每次计算下一轮是都采用的是整除（应该是这个原因，至于其中具体的数学推理则无能为力了）。如果倒过来从最后一轮往里面添加就会出错，因为不知道后面需不需要添加以及何时添加。\n","date":"2020-07-15T00:00:00Z","permalink":"http://localhost:1313/p/hdu2211_%E6%9D%80%E4%BA%BA%E6%B8%B8%E6%88%8F/","title":"hdu2211_杀人游戏"},{"content":"由于这学期开设了操作系统的课程，而现在又是疫情期间，学校也已经通知本学期没有线下课程了，而学校的操作一天老师基本都是让我们自学（还是外教），光看书实在难以进行（英文原版），故前些日子在网上找到了哈工大李治军老师的操作系统课程，讲述得算很细致了。而课程刚好有配套的实验，为了图方便，我就在自己的虚拟机上搭建了相关的环境（当然这过程中也走了不少弯路），开始实验之旅。\n本篇博客是相关记录的开篇，对应的是操作系统的引导部分。主要想记录一下实验过程中遇到的问题。\nbootsect.s (引导部分)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 SETUPLEN=2 SETUPSEG=0x07e0 entry _start _start: ! 首先读入光标位置 mov ah,#0x03 xor bh,bh int 0x10 ! 显示字符串\u0026amp;quot;MessizOS is ready!\u0026amp;quot; ! 要显示的字符串长度 mov cx,#24 mov bx,#0x0007 mov bp,#msg1 ! es:bp 是显示字符串的地址 ! 相比 linux-0.11 中的代码，需要增加对es的处理因为原来代码中输出之前已经处理了es mov ax,#0x07c0 mov es,ax mov ax,#0x1301 int 0x10 load_setup: mov dx,#0x0000 mov cx,#0x0002 mov bx,#0x0200 mov ax,#0x0200+SETUPLEN int 0x13 jnc ok_load_setup mov dx,#0x0000 mov ax,#0x0000 int 0x13 jmp load_setup ok_load_setup: jmpi 0,SETUPSEG ! msg1处放置字符串 msg1: ! 换行+回车 .byte 13,10 .ascii \u0026amp;quot;MessizOS is ready!\u0026amp;quot; ! 两对换行+回车 .byte 13,10,13,10 ! boot_flag必须在最后两个字节 .org 510 ! 设置引导扇区标志0xAA55 ! 必须有它才能引导 boot_flag: .word 0xAA55 这段代码首先是要实现启动时在屏幕上打印出一行字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ! 首先读入光标位置 mov ah,#0x03 xor bh,bh int 0x10 ! 显示字符串\u0026amp;quot;MessizOS is ready!\u0026amp;quot; ! 要显示的字符串长度 mov cx,#24 mov bx,#0x0007 mov bp,#msg1 ! es:bp 是显示字符串的地址 ! 相比 linux-0.11 中的代码，需要增加对es的处理因为原来代码中输出之前已经处理了es mov ax,#0x07c0 mov es,ax mov ax,#0x1301 int 0x10 先通过10号中断读取当前光标位置，再通过13号中断将指定的字符串打印到光标位置。\n至于字符串部分则在下面：\n1 2 3 4 5 6 msg1: ! 换行+回车 .byte 13,10 .ascii \u0026amp;quot;MessizOS is ready!\u0026amp;quot; ! 两对换行+回车 .byte 13,10,13,10 由于有两对换行+回车，因此字符串长度需要+6。\n1 SETUPSEG=0x07e0 由于历史原因，操作系统启动之后执行的代码地址是0x7c00，故将SETUPSEG设置为0x07e0。段地址是要左移4位（也就是*16）才得到实际地址的，所以0x07e0实际上是0x7e00，为什么呢？\n0x7e00 - 0x7c00 = 0x200。0x200是什么？？\n0x200转换成十进制恰好是512！再仔细思考一下，发现最后几行代码是：\n1 2 3 4 5 6 7 ! boot_flag必须在最后两个字节 .org 510 ! 设置引导扇区标志0xAA55 ! 必须有它才能引导 boot_flag: .word 0xAA55 实际上bootsect部分的代码恰好被设置成了512字节大小（.org 510 再加上最后语句.word的一个字，也就是两字节），后面紧跟的恰好是setup部分的代码。\n1 2 3 4 5 6 7 load_setup: mov dx,#0x0000 mov cx,#0x0002 mov bx,#0x0200 mov ax,#0x0200+SETUPLEN int 0x13 jnc ok_load_setup 这部分代码则是通过13号中断从磁盘中读入数据到内存，具体的参数不细说了。\n总体来说，bootsect实现了显示字符串\u0026quot;MessizOS is ready!\u0026quot;，以及读入setup部分代码并且跳转到setup部分继续执行。\nsetup.s\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 INITSEG = 0x9000 entry _start _start: ! 首先读入光标位置 mov ah,#0x03 xor bh,bh int 0x10 mov cx,#25 mov bx,#0x0007 mov bp,#msg2 mov ax,cs mov es,ax mov ax,#0x1301 int 0x10 mov ax,cs mov es,ax ! 初始化ss:sp mov ax,#INITSEG mov ss,ax mov sp,#0xFF00 ! 读入硬件信息至0x90000(INITSEG)处 mov ax,#INITSEG mov ds,ax mov ah,#0x03 xor bh,bh int 0x10 ! 读出光标位置放入0x90000 mov [0],dx ! 读入内存大小 mov ah,#0x88 int 0x15 mov [2],ax ! 从0x41处拷贝16个字节(磁盘参数表) mov ax,#0x0000 mov ds,ax lds si,[4*0x41] mov ax,#INITSEG mov es,ax mov di,#0x0004 mov cx,#0x10 ! 重复16(0x10)次 rep movsb ! 移动 ds:si ---\u0026amp;gt; es:di (move string byte) ! 打印前准备 mov ax,cs mov es,ax mov ax,#INITSEG mov ds,ax ! Cursor Position mov ah,#0x03 xor bh,bh int 0x10 mov cx,#13 mov bx,#0x0007 mov bp,#msg_cursor mov ax,#0x1301 int 0x10 mov dx,[0] call print_hex ! Memory Size mov ah,#0x03 xor bh,bh int 0x10 mov cx,#14 mov bx,#0x0007 mov bp,#msg_memory mov ax,#0x1301 int 0x10 mov dx,[2] call print_hex ! Add KB mov ah,#0x03 xor bh,bh int 0x10 mov cx,#2 mov bx,#0x0007 mov bp,#msg_kb mov ax,#0x1301 int 0x10 ! Cyles mov ah,#0x03 xor bh,bh int 0x10 mov cx,#8 mov bx,#0x0007 mov bp,#msg_cyles mov ax,#0x1301 int 0x10 mov dx,[4] call print_hex ! Heads mov ah,#0x03 xor bh,bh int 0x10 mov cx,#8 mov bx,#0x0007 mov bp,#msg_heads mov ax,#0x1301 int 0x10 mov dx,[6] call print_hex ! Sectors mov ah,#0x03 xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 mov bp,#msg_sectors mov ax,#0x1301 int 0x10 mov dx,[12] call print_hex inf_loop: jmp inf_loop ! --------------------------函数-------------------------- ! 打印信息 print_hex: ! 4个16进制数字 mov cx,#4 ! bp指向栈顶，将栈顶的值放入dx ! mov dx,(bp) print_digit: ! 循环，将dx的高4为移动到低4位 rol dx,#4 mov ax,#0xe0f ! ah 为中断请求值，al的低4位为掩码 and al,dl add al,#0x30 cmp al,#0x3a ! 不大于十 jl outp ! 大于十，再加7 add al,#0x07 outp: int 0x10 loop print_digit ret ! 打印回车换行 print_nl: ! 0xd是13，CR mov ax,#0xe0d int 0x10 ! 0xa是10，LF mov al,#0xa int 0x10 ret ! --------------------------函数-------------------------- ! --------------------------文本数据-------------------------- msg2: ! 换行+回车 .byte 13,10 .ascii \u0026amp;quot;Now we are in SETUP\u0026amp;quot; ! 两对换行+回车 .byte 13,10,13,10 msg_cursor: .byte 13,10 .ascii \u0026amp;quot;Cursor Pos:\u0026amp;quot; msg_memory: .byte 13,10 .ascii \u0026amp;quot;Memory size:\u0026amp;quot; msg_cyles: .byte 13,10 .ascii \u0026amp;quot;Cyles:\u0026amp;quot; msg_heads: .byte 13,10 .ascii \u0026amp;quot;Heads:\u0026amp;quot; msg_sectors: .byte 13,10 .ascii \u0026amp;quot;Sectors:\u0026amp;quot; msg_kb: .ascii \u0026amp;quot;KB\u0026amp;quot; ! --------------------------文本数据-------------------------- ! boot_flag必须在最后两个字节 .org 510 ! 设置引导扇区标志0xAA55 ! 必须有它才能引导 boot_flag: .word 0xAA55 setup程序首先复制了bootsect的部分代码，打印出了字符串\u0026quot;Now we are in SETUP\u0026quot;。而由于setup部分也是两个扇区，所以最后也是 .org 510。\nsetup的另一项功能是将一些硬件参数读出来，并显示在屏幕上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 print_hex: ! 4个16进制数字 mov cx,#4 ! bp指向栈顶，将栈顶的值放入dx ! mov dx,(bp) print_digit: ! 循环，将dx的高4为移动到低4位 rol dx,#4 mov ax,#0xe0f ! ah 为中断请求值，al的低4位为掩码 and al,dl add al,#0x30 cmp al,#0x3a ! 不大于十 jl outp ! 大于十，再加7 add al,#0x07 outp: int 0x10 loop print_digit ret 这部分代码是打印函数，dx中放的是需要打印的参数，存放的是二进制数值，所以要转化成对应的十六进制ascii码需要加上0x30或者是0x37（\u0026lsquo;0\u0026rsquo;的ascii码是30h，大写字母则需再加7）。\n注意！！！此处我犯了个错误导致打印不出来，\n1 ! mov dx,(bp) 就是这一句，之前是没有注释掉的，bp所指向的并不是数据区，故不能这么用，若是bp指向数据区则没问题。\n1 2 3 4 5 6 7 8 9 10 11 ! Cursor Position mov ah,#0x03 xor bh,bh int 0x10 mov cx,#13 mov bx,#0x0007 mov bp,#msg_cursor mov ax,#0x1301 int 0x10 mov dx,[0] call print_hex 最后 mov dx,[0] 已经将0x9000:0位置的两个字节数据放进了dx，所以上面那句是不需要的。\n而上述代码中我犯了另一个错误\n1 mov ax,#0x1301 本来这里的0x没有加，这就变成了十进制数，这与我们预期的并不同，所以打印也就失败了。（这里真的是用调试器单步了好久才看出来）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ! 读入内存大小 mov ah,#0x88 int 0x15 mov [2],ax ! 从0x41处拷贝16个字节(磁盘参数表) mov ax,#0x0000 mov ds,ax lds si,[4*0x41] mov ax,#INITSEG mov es,ax mov di,#0x0004 mov cx,#0x10 ! 重复16(0x10)次 rep movsb ! 移动 ds:si ---\u0026amp;gt; es:di (move string byte) 至于此处的读入就不细说了。\n总结\nbootsect打印字符串 \u0026ndash;\u0026gt; 读入setup \u0026ndash;\u0026gt; 打印字符串，读入硬件信息，打印硬件信息。\nps：博客是不是写得太长了点。。。我好累（哭）\\\n","date":"2020-04-28T00:00:00Z","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/","title":"操作系统实验学习记录（1）"},{"content":"今天是20年3月1日，有感而发想写一篇日记抒发一下内心所思。\n妈早上出门去买菜，到家后随口说：楼下的那个老头子没了。我还有些发懵，心里却已经有了不好的想法。追问之下，妈确认了我的想法。\n\u0026ldquo;好像就四五个人\u0026rdquo;\n\u0026ldquo;看他们手上捧着的照片才知道\u0026rdquo;\n\u0026hellip;\u0026hellip;\n正好与我脑中的他对上了。他好像从来都是一个人，一个人生活。有的时候看见他傍晚推着自行车或是步行出去，大概是散步吧，也是一个人。\n我是从什么时候开始对他有印象的呢？一点头绪也没有。或许是刚搬到这里，或许是小学\u0026hellip;\u0026hellip;他也从没有给我留下深刻的印象\u0026mdash;\u0026mdash;大家都有各自的生活，谁会在意一个与自己生活几乎不会有交集的陌生人呢。\n唯一的印象就是傍晚出门以及深夜归来的蹒跚身影。\n他身材挺高大的，看上去也壮实，或许年轻的时候是当兵的吧。好像也没有很老，大概六七十。总是穿一身军大衣，有些破旧了。家里大门上的塑料膜自我见到起，直到他离去也未曾剥落。曾经也瞥见过他家里，是未曾装修的，毛坯房灰色的水泥地面，墙面，没有什么鲜艳的颜色。\n一个人孤独的样子，或许在他人眼中，才是最悲伤的。\n","date":"2020-03-01T00:00:00Z","permalink":"http://localhost:1313/p/%E6%9D%82%E8%B0%881/","title":"杂谈1"},{"content":"mov语句简介\nmov指令用来实现数据的移动，一般后面会跟有两个操作数：源和目标\n例如：\n1 movq %rax, %rsi 在ATT格式的汇编代码中，前者为源，后者为目标，因此上述语句实现的是将%rax寄存器的内容传送到%rsi寄存器中。\n操作数及类型对应的值\n有三种类型的操作数，分别为： - 立即数（immediate）：$0x1F - 寄存器（register） - 内存引用\n寻址模式为：\nImm(rb，ri，s)\n其中，Imm代表立即数，rb代表基址寄存器，ri代表变址寄存器，s是比例系数。\n则操作数的值为：\nM（Imm + rb 的值 + ri的值 * s）\n其中M表示括号里的值对应的地址。\n数据传送指令\n\\\n指令 描述\nMOV S, D 传送(S-\u0026gt;D) movb 传送字节 movw 传送字（两字节） movl 传送双字（四字节） movq 传送四字（八字节） movabsq 传送绝对的四字\n注意点：\nmovl指令以64位的寄存器为目标时，会自动将高32位（四字节）设置为0 其余语句均只改变其传送数据的字节，而不会补0，或进行符号扩展 movq语句实际上并不能传送64位，而只能传送32位，其高32位由低32位数据符号扩展而来 movabsq指令才能传送64位数据，但要注意，只能以寄存器为目标操作数 0扩展指令：\n指令 描述\nMOVZ S, D 零扩展传送(S-\u0026gt;D) movzbw b-\u0026gt;w movzbl b-\u0026gt;l movzbq b-\u0026gt;q movzwl w-\u0026gt;l movzwq w-\u0026gt;q\n上述指令中缺少了\u0026quot;movzlq\u0026quot;，但实际上并不需要，因为上面说到过，movl指令本身就实现了这个功能。\n符号扩展：\n指令 描述\nMOVS S, D 符号扩展传送(S-\u0026gt;D) movsbw b-\u0026gt;w movsbl b-\u0026gt;l movsbq b-\u0026gt;q movswl w-\u0026gt;l movswq w-\u0026gt;q movslq l-\u0026gt;q cltq 把%eax符号扩展到%rax\n注意：\n上述零扩展和符号扩展指令源操作数为寄存器或内存地址，目标操作数为寄存器 判断mov指令后缀的方法\n\\\n优先级按照以下几条规定：\n有寄存器按照寄存器大小 两个操作数都是寄存器则按照目标寄存器 其次是立即数大小 内存地址优先级最低 终于总结完了\n累~\nEND\n","date":"2020-02-09T00:00:00Z","permalink":"http://localhost:1313/p/att%E6%B1%87%E7%BC%96%E4%B8%ADmov%E6%8C%87%E4%BB%A4/","title":"ATT汇编中mov指令"},{"content":"今天看书时遇到set的使用，于是将给的例子自己写了一遍，结果意外地发现了一些问题。\n题目很简单：\n1 2 3 4 5 6 7 8 9 问题： 输入文本，找出不同单词，按字典顺序从小到大输出，不区分大小写。 样例输入： Adventures in Disneyland Two blondes were going to Disneyland when they came to a fork in the road. The sign read:\u0026amp;quot;Disneyland Left.\u0026amp;quot; So they went home. 下面直接放上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026amp;lt;iostream\u0026amp;gt; #include\u0026amp;lt;string\u0026amp;gt; #include\u0026amp;lt;sstream\u0026amp;gt; #include\u0026amp;lt;set\u0026amp;gt; using namespace std; set\u0026amp;lt;string\u0026amp;gt; dict; int main() { string word, buff; stringstream sstream; while (cin \u0026amp;gt;\u0026amp;gt; word) { //循环处理一个输入的单词 for (int i = 0; i \u0026amp;lt; word.size(); i++) { if (isalpha(word[i])) word[i] = tolower(word[i]); else word[i] = \u0026amp;#39; \u0026amp;#39;; } //此处需清空stringstream的缓冲区，否则无法复用sstream读取多组数据 //而.clear()方法不能真正做到清除，而会使内存越来越高，因此采用.str()方法 //clear清空的是标志位，实际占用的内存并未释放！！！ //先将其赋为空字符串\u0026amp;quot;\u0026amp;quot;，再调用clear()方法 sstream.str(\u0026amp;quot;\u0026amp;quot;); sstream.clear(); sstream \u0026amp;lt;\u0026amp;lt; word; //可能出现两个单词被标点连接，从而处理完为两个单词的情况，故使用stringstream while (sstream \u0026amp;gt;\u0026amp;gt; buff) dict.insert(buff); //加入集合 } //输出结果（set模板类并没有定义[]，故需要通过迭代器来遍历） for (auto it = dict.begin(); it != dict.end(); it++) cout \u0026amp;lt;\u0026amp;lt; *it \u0026amp;lt;\u0026amp;lt; endl; return 0; } 开始时没有这两行代码，结果输出只有一个单词\n1 2 sstream.str(\u0026amp;quot;\u0026amp;quot;); sstream.clear(); 经过调试，发现是因为sstream是在前面定义的，第一次读取后，缓冲区一直没有刷新，所以后面的单词无法读入sstream。而书上的代码则在需要读入处每次都重新定义一个stringstream类型的变量，所以没有这个问题。\n1 2 3 ... stringstream ss(word); //书上该处的代码如是 ... 经过一番搜索，找到了解决办法，即运用clear方法，但同时得知，clear方法仅仅清除了标志位，而对于实际的缓冲区内存并未做实际的释放处理。所以需要在clear之前手动将sstream赋值为空字符串，即：\n1 sstream.str(\u0026amp;quot;\u0026amp;quot;); ","date":"2020-02-04T00:00:00Z","permalink":"http://localhost:1313/p/stringstream%E5%A4%8D%E7%94%A8%E4%B8%AD%E5%88%B7%E6%96%B0%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98/","title":"Stringstream复用中刷新缓冲区的问题"},{"content":"从开始准备写这一篇到实际开始中间鸽了好多天。。\n主要是因为懒以及不断的wrong answer，最后在网友博客的帮助下最终ac。\n问题描述如下：\nProblem Description\n1 Given a sequence a[1],a[2],a[3]......a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14. Input\n1 The first line of the input contains an integer T(1\u0026amp;lt;=T\u0026amp;lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1\u0026amp;lt;=N\u0026amp;lt;=100000), then N integers followed(all the integers are between -1000 and 1000). Output\n1 For each test case, you should output two lines. The first line is \u0026amp;quot;Case #:\u0026amp;quot;, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases. Sample Input\n1 2 3 2 5 6 -1 5 4 -7 7 0 6 -1 1 -6 7 -5 Sample Output\n1 2 3 4 5 Case 1: 14 1 4 Case 2: 7 1 6 下面直接放上完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include\u0026amp;lt;iostream\u0026amp;gt; using namespace std; int main() { //变量定义 int caseNum; //输入组数 int num; //每组数量 int arry[100005]; //存放输入 int currMax, max; //当前最大和 以及 最大和 int left, right, temp; //左右，temp用于计算出left cin \u0026amp;gt;\u0026amp;gt; caseNum; for (int i = 1; i \u0026amp;lt;= caseNum; ++i) { cin \u0026amp;gt;\u0026amp;gt; num; //接受输入 for (int j = 0; j \u0026amp;lt; num; ++j) { cin \u0026amp;gt;\u0026amp;gt; arry[j]; } //变量初始化 currMax = 0; max = -1001; left = 1; right = 1; temp = 1; for (int k = 0; k \u0026amp;lt; num; ++k) { currMax += arry[k]; if (max \u0026amp;lt; currMax) { max = currMax; left = temp; right = k + 1; } if (currMax \u0026amp;lt; 0) { currMax = 0;//此处不能写成currMax = arry[k]; temp = k + 2; } } //输出 cout \u0026amp;lt;\u0026amp;lt; \u0026amp;quot;Case \u0026amp;quot; \u0026amp;lt;\u0026amp;lt; i \u0026amp;lt;\u0026amp;lt; \u0026amp;quot;:\u0026amp;quot; \u0026amp;lt;\u0026amp;lt; endl; cout \u0026amp;lt;\u0026amp;lt; max \u0026amp;lt;\u0026amp;lt; \u0026amp;quot; \u0026amp;quot; \u0026amp;lt;\u0026amp;lt; left \u0026amp;lt;\u0026amp;lt; \u0026amp;quot; \u0026amp;quot; \u0026amp;lt;\u0026amp;lt; right \u0026amp;lt;\u0026amp;lt; endl; if (i != caseNum) { cout \u0026amp;lt;\u0026amp;lt; endl; } } return 0; } 之前就曾写过这一道题，但一直超时\u0026mdash;\u0026mdash;因为当时用的是最暴力的嵌套循环遍历\n时间复杂度为O($n^2$)\n这种算法的优点在于只需要循环一次，时间复杂度为O(n)。\n算法主体部分代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 for (int k = 0; k \u0026amp;lt; num; ++k) { currMax += arry[k]; if (max \u0026amp;lt; currMax) { max = currMax; left = temp; right = k + 1; } if (currMax \u0026amp;lt; 0) { currMax = 0;//此处不能写成currMax = arry[k]; temp = k + 2; } } 从数组头开始，每次将该元素累加至currMax上，作为当前子列的最大值，再与max比较，如果大于max则更新其值。\n最关键的一步在于，判断currMax是否小于0，若小于0，则将该子列舍去，从下一位置开始。这里蕴含的原理在于：一旦currMax小于0了，这个子列一定会使后面的子列变小，所以从下一位置开始一定比加上前面的子列大。\n我开始还有这样的疑问：它并没有考虑所有的子列，万一从a[0]开始，至a[3]突然小于0了，那么就直接从a[4]开始，而a[2]或a[3]开始的子列就没有得到验证。\n然而如果a[3]加上去之后小于0了，那么说明至少前一项（a[2]）减去此项（a[3]）小于0。因为如果大于0，要满足子列加到a[3]突然变负，则需要a[2]之前的项小于0，而这是不可能的，因为如果小于0，则在之前的步骤中已经被舍去了。\n因而我的疑问只是没有根据的一厢情愿罢了。\n（拖沓了近3周，效率啊！！！）\n","date":"2019-09-22T00:00:00Z","permalink":"http://localhost:1313/p/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E9%97%AE%E9%A2%98/","title":"最大子列问题"}]