---
title: "算法学习笔记"
description: 算法学习笔记
date: 2021-02-25
image: 
categories:
    - 算法
musicid:
---

# [](#数据结构 "数据结构"){.headerlink}数据结构

## [](#哈希 "哈希"){.headerlink}哈希

### [](#拉链法 "拉链法"){.headerlink}拉链法

### [](#开放寻址法 "开放寻址法"){.headerlink}开放寻址法

### [](#字符串哈希 "字符串哈希"){.headerlink}字符串哈希

字符串哈希用于快速判断两字符串是否相同，时间复杂度为O(1)，需要保证的前提是不同的字符串映射后的值不相等（即要求哈希表不发生冲突）。

举例来看：对于字符串"abcd"，将其看作一个P进制的数，则"abcd"映射的值取为：

> (a\*P\^3 + b\*P\^2 + c\*P\^1 + d\*P\^0) mod Q

其中a，b，c，d分别为ascii码。

通常将P取值为 *131* 或 *13331*
可以尽可能地避免冲突。（玄学），由于溢出，需要对Q取模，Q一般取为2\^64，故可以直接用unsigned
long long
来存储（恰好是2\^64），溢出就相当于取模，因此省去了取模的计算。

对于一个字符串，假设h(i)表示其i前缀的哈希值，例如上述例子中h(2)表示"ab"的哈希值。则h(i)的初始化可以用以下式子：

> h(i) = h(i - 1) \* P + str(i)

其中h(0) = 0

要得到第l到第r位之间的字符串哈希值，则用以下公式：

> value = h(r) - h(l - 1) \* P\^(r - l + 1)

------------------------------------------------------------------------

# [](#图论-amp-搜索 "图论&搜索"){.headerlink}图论&搜索 {#图论-amp-搜索}

## [](#数和图的存储 "数和图的存储"){.headerlink}数和图的存储

### [](#邻接矩阵 "邻接矩阵"){.headerlink}邻接矩阵

g\[a\]\[b\]表示a节点指向b节点的边，无权值则可用bool数组，有权值则保存对应权值。

### [](#邻接表 "邻接表"){.headerlink}邻接表

类似hash表拉链法

```c++
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a-&gt;b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
```

h数组下标表示第几个结点，而e和ne点的下标则表示第几个添加的，注意：不同时间添加的可能指的是同一个结点。比如：第4次操作添加了结点5，而第9次操作又添加的结点5，h\[5\]表示的是第5个结点邻接表的首元素(的下标)，而e\[4\]和e\[9\]都等于5；ne\[4\]和ne\[9\]则分别表示这两次操作对5这个结点的不同指向(或被指向)。

### [](#深度优先遍历-DFS "深度优先遍历(DFS)"){.headerlink}深度优先遍历(DFS) {#深度优先遍历-DFS}

```c++
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```

### [](#广度优先遍历-BFS "广度优先遍历(BFS)"){.headerlink}广度优先遍历(BFS) {#广度优先遍历-BFS}

```c++
queue&lt;int&gt; q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```

## [](#最短路问题 "最短路问题"){.headerlink}最短路问题

![](/post/5989a513/%E6%9C%80%E7%9F%AD%E8%B7%AF.png)

## [](#Dijkstra最短路算法 "Dijkstra最短路算法"){.headerlink}Dijkstra最短路算法 {#Dijkstra最短路算法}