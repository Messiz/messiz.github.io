---
title: "分布式事务"
description: 
date: 2024-06-13
image: 
categories:
    - 分布式
musicid:
---

# 2PC
Two-phase commit protocal，两阶段提交协议

从角色来划分，包括一个**协调者（coordinator）**和若干**参与者（participant）**；

从阶段来划分，包括**准备（prepare）**和**提交（commit）**阶段；

示意图如下：

**准备阶段**

![](https://cdn.jsdelivr.net/gh/Messiz/image-bed/test/20240924232311.png)

**提交阶段**

![](https://cdn.jsdelivr.net/gh/Messiz/image-bed/test/20240924232315.png)



## 优点
对于业务没有侵入，可以利用数据库自身的功能进行本地事务提交和回滚，而不用额外实现。

## 缺点
### 同步阻塞
在第一阶段，参与者执行了准备命令后，会处于等待协调者消息的同步阻塞状态，影响处理效率；

### 单点故障
其实是一主多从的结构，因此如果主节点（协调者）宕机，则整个事务都不能执行；

而且如果在协调者发送准备信息后宕机，则所有参与者都将处于同步阻塞状态。

### 数据不一致
可能由于网络问题导致某些节点没有收到提交请求，导致部分参与者提交了事务，而有些参与者没有提交。



## 分布式数据库对2PC的改进
Percolator模型

对于下面这个事务：“yes”转账100给“you”

![](https://cdn.jsdelivr.net/gh/Messiz/image-bed/test/20240924232320.png)

+ 准备阶段，yes和you两边分别新增了一条记录，yes这里data减少100，you的data增加100；同时事务管理器记录下这次操作的日志；注意这里Lock部分有数据代表这是私有数据，别的事务读取不到。
+ yes这里的Lock获得了一个标志PK，而you这里的Lock指向了PK，说明you这里记录的更新依赖于PK这条记录；
+ 提交阶段，事务管理器只会向PK这条记录发送提交请求，PK记录会将PK标志删除，此时该条记录变为公开版本，其他事务可见；
+ 下一次访问 PK@yes 记录时会发现PK记录已经提交，所以会将 PK@yes 也删去提交；注意这里实际上会有后台线程扫描进行此操作，因此不会真的等到下一次访问才提交，不会影响执行效率。



### 改进点
+ 提交阶段只与一个参与者交互，这个操作是原子的，解决了**数据不一致**问题；
+ 事务管理器会记录操作日志，在宕机后选举新的事务管理器可以通过日志继续工作，解决了**单点故障**问题；
+ 后台线程扫描事务状况，在事务管理宕机后会回滚各个参与者的事务（2PC中参与者没有接收到协调者消息不会进行提交或回滚操作）。



## XA规范-2PC落地实现
XA规范是基于2PC的，XA是对DTP（Distributed Transaction Processing）模型中的事务管理器（TM）和资源管理器（RM）之间的交互进行约束后形成的规范。

![](https://cdn.jsdelivr.net/gh/Messiz/image-bed/test/20240924232324.png)

AP：应用程序，事务发起者

RM：资源管理器，可以认为是数据库，对应上面2PC中的参与者

TM：事务管理器，对应2PC中的协调者

实际实现时可以由一个角色实现两个功能，比如AP实现TM的功能



### MySQL XA
+ Client作为AP和TM的角色;
+ 准备阶段，Client向不同的数据库（RM）发送不同的指令；
+ 提交阶段，Client根据RM返回的情况决定执行commit还是rollback。





# 3PC
相较于2PC，多了一个预提交阶段

3PC和2PC对应关系如下：

**准备（询问参与者是否状态正常） <---> 无对应**

**预提交（发送指令） <---> 准备**

**提交（通知提交） <---> 提交**

![](https://cdn.jsdelivr.net/gh/Messiz/image-bed/test/20240924232328.png)

引入准备阶段的目的就是为了解决2PC中由于个别参与者不正常导致其他参与者锁定资源，但异常情况发生几率较小，因此额外引入的阶段会在正常情况下带来额外的时间开销，不划算。

3PC同时引入了超时机制，当预提交阶段过后，如果迟迟未收到协调者提交请求，参与者会**自动提交**，因为在第一步准备阶段时就已经确定参与者是否都认可，因此进入预提交阶段说明所有参与者都可以执行并提交。



**实际上3PC的设计是想解决2PC中带来的问题，但实际上并没有很好解决，反而性能更差了，3PC也没有落地实现。**



# TCC
2PC和3PC都是针对数据库的事务提交和回滚，但很多情况下，业务操作不止局限于数据库，也可能是发送短信，上传图片等操作，TCC就是一种**业务层面的两阶段提交**方法

+ TCC - Try Confirm Cancel，分别指代业务层面要实现的3个方法
+ 第一阶段（Try），资源检查预留阶段；
+ 第二阶段（提交、回滚）

例如对于一个扣款的服务，Try方法用于冻结扣款资金，Confirm用于执行真正的扣款，Cancel方法用于Try方法的回滚（资金解冻）。

![](https://cdn.jsdelivr.net/gh/Messiz/image-bed/test/20240924232332.png)

TCC对于业务有很大侵入，但是不会阻塞资源，每个方法都是直接提交事务的。

如果部分Confirm失败，则会一直重试，直到成功，或者记录下来，人工处理。



## 幂等性
Try、Confirm、Cancel三个方法需要保证幂等性，因为网络问题可能造成请求多次发送，需要幂等性保证不会因为多次执行出错。

## 空回滚问题
Try方法由于网络问题超时而没有到达参与者，事务管理器会发出Cancel命令，如果此时收到Cancel，需要能够处理这种没有执行Try的情况下进行Cancel。

## 悬挂问题
在空回滚问题执行了Cancel后此前超时的Try命令到达了；在空回滚之后需要记录一下，防止这种情况下Try的再次调用。



# TCC变体
## 没有Try的TCC
取消了Try操作，在一阶段直接执行Confirm操作，第二阶段判断成功则无操作，失败则执行Cancel

其实和2PC很像：一阶段执行操作，二阶段可能回滚；只是2PC一阶段没有提交，这里一阶段提交了。

![](https://cdn.jsdelivr.net/gh/Messiz/image-bed/test/20240924232337.png)

## 异步TCC
如果某些服务很难改造，且不会影响主业务决策，可以引入可靠消息服务，通过消息服务来代替个别服务进行Try、Confirm、Cancel。

Try写入消息，Confirm发送消息，Cancel取消消息发送



# 本地消息表
这是基于最终一致性思想实现的一种方案。

将**业务执行**和**消息插入**放在同一个本地事务中执行，然后执行下一个服务，如果调用成功则改变这条本地消息的状态，如果失败则会一直调用。

![](https://cdn.jsdelivr.net/gh/Messiz/image-bed/test/20240924232347.png)



# 事务消息
RocketMQ提供事务消息，事务开始时发送**半消息**（暂不能投递的消息，发送方已经将消息成功发送到了 MQ 服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半消息）给broker，此时消息对消费者不可见，当本地事务提交了，半事务也就提交，此时消费者可见，也就可以消费了。

broker如果很久没有等到半消息提交或是回滚的消息，则会反查生产者，保证事务一致性。

