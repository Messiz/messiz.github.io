---
title: "最左匹配原则"
description: MySQL中联合索引下的最左匹配原则
date: 2024-09-27T23:29:01+08:00
image: 
categories:
    - MySQL
    - 索引
musicid:
---

在学习MySQL索引的过程中遇到了最左匹配原则这个概念，由于我有些钻牛角尖的精神，其中有些问题开始没有想明白，现在可能了解了（带有一点自己的猜测），记录一下，帮助自己加深印象~

# 什么是最左匹配原则
最左匹配原则是基于联合索引产生的概念，至于联合索引是指将一条记录的某几列共同形成一个索引，举例来说，如果要以A，B，C三列形成一个联合索引，应该通过如下语句：

```sql
ALTER TABLE `table_name` ADD INDEX index_name (`A`, `B`, `C`)
```

以InnoDB为例，其索引是由B+树存储的，由于B+树的特性，对于联合索引来说，B在A固定的情况下是有序的，否则是无序的；同理C在A、B均固定的情况下是有序的，否则是无序的。也就引出了最左匹配原则，我简单自己概括一下就是：

对于联合索引来说，是从左向右匹配的，不能跳过某个索引列，同时在遇到范围查询（> < != between like 等）后会失效。

用上面的例子来说，对于查询条件"A = 1, B = 2, C = 3"来说，三个条件都是可以利用索引的，而对于"B = 2, C = 3"，由于跳过了A，是无法利用索引的；此外对于"A = 1, B > 2, C = 3"，A和B可以利用索引，而C不行。



# 原理是什么
其实原理很简单，前面说到，对于联合索引而言，除了最左侧的索引列是由B+树本身保证其顺序外，其余列都是全局无序，局部有序的。全局无序很好理解，局部有序则是说，如果其左侧的索引列固定，则在这个范围内该列是有序的。举例来说：当A = 1时，有若干条记录，那么在此范围内，B是有序的。



# 为什么不能跳过某个索引列？
很简单，如果跳过A，那么B是全局无序的，也就是说，对于B = 2这样的条件，没办法通过B+树去在O(logN)内快速定位，需要遍历所有记录。

# 为什么范围后不能利用索引？
这是我困扰的点，因为就算能够利用索引，对于最左列之外的索引列，都需要进行顺序查找，而非B+树的k分查找，时间复杂度是线性的。

其实是这样的，对于"A = 1, B = 2, C = 3"这样的条件，我们在找到A = 1的第一条记录后，顺序遍历，直到遇见第一个A != 1的记录，中间全是满足第一个条件的记录；同理，顺序遍历找到第一个B = 2与第一个B != 2的记录，则中间都是满足条件A = 1，B = 2的记录；C也同理。如下图所示：

![](https://cdn.jsdelivr.net/gh/Messiz/image-bed/test/20240927232837.png)

我们可以逐层确定各索引列的范围。

而对于"A = 1, B > 2, C = 3"这样的条件，C的搜索不再是B范围的子集，而是整个B的范围，因为C = 3在B > 2的所有记录中是无序的，因此不能找到边界即停止查找，而是要查找B > 2的所有记录。



